
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth Anything 3 - Point Cloud Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/FlyControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/math/ConvexHull.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/ConvexGeometry.js"></script>
    <script>
        // Prefix all /api/... requests with an overridable base URL so the UI can talk to a remote API.
        const urlParams = new URLSearchParams(window.location.search);
        const storedApi = (() => {
            try { return localStorage.getItem('da3_api_base'); } catch (_) { return null; }
        })();
        const normalizeBase = (base) => {
            if (!base) return '';
            return base.endsWith('/') ? base.slice(0, -1) : base;
        };
        const deriveDefaultBase = () => {
            const host = (window.location && window.location.hostname) ? window.location.hostname : 'localhost';
            // Default to http with API on port 5000
            return `http://${host || 'localhost'}:5000`;
        };
        let API_BASE = normalizeBase(
            urlParams.get('api') ||
            (typeof window !== 'undefined' ? window.API_BASE_URL : '') ||
            storedApi ||
            deriveDefaultBase()
        );
        try { localStorage.setItem('da3_api_base', API_BASE); } catch (_) {}
        const originalFetch = window.fetch.bind(window);
        window.fetch = (input, init) => {
            if (typeof input === 'string' && input.startsWith('/api/')) {
                return originalFetch(API_BASE + input, init);
            }
            return originalFetch(input, init);
        };
        window.setApiBase = (base) => {
            API_BASE = normalizeBase(base);
            try { localStorage.setItem('da3_api_base', API_BASE); } catch (_) {}
            updateApiDisplay();
            console.log('API base set to', API_BASE);
        };

        async function verifyApiBase() {
            const candidates = [];
            if (API_BASE) candidates.push(API_BASE);

            const host = (window.location && window.location.hostname) ? window.location.hostname : 'localhost';
            const fallback = normalizeBase(`http://${host || 'localhost'}:5000`);
            if (!candidates.includes(fallback)) candidates.push(fallback);

            for (const base of candidates) {
                try {
                    const res = await originalFetch(base + '/api/v1/health', { method: 'GET' });
                    if (res.ok) {
                        setApiBase(base);
                        return true;
                    }
                } catch (err) {
                    console.warn('API probe failed for', base, err);
                }
            }

            const manual = prompt('API server not reachable. Enter API base (e.g., http://127.0.0.1:5000)', candidates[0] || fallback);
            if (manual) {
                setApiBase(manual);
                return verifyApiBase();
            }

            alert('API is not reachable. Please restart with a valid API base to use the UI.');
            return false;
        }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        /* Full-screen Three.js canvas */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Top button bar */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            z-index: 100;
        }

        .top-bar button {
            padding: 10px 20px;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.5);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .top-bar button:hover {
            background: rgba(59, 130, 246, 0.4);
            border-color: rgba(59, 130, 246, 0.8);
        }

        .top-bar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .top-bar .title {
            font-size: 18px;
            font-weight: 600;
            margin-right: auto;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        /* Bottom button bar */
        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            gap: 15px;
            z-index: 100;
        }

        .bottom-bar button {
            padding: 12px 24px;
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.5);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bottom-bar button:hover:not(:disabled) {
            background: rgba(16, 185, 129, 0.4);
            border-color: rgba(16, 185, 129, 0.8);
            transform: translateY(-2px);
        }

        .bottom-bar button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Responsive icon-only top/bottom bars */
        @media (max-width: 768px) {
            .top-bar {
                height: 56px;
                gap: 10px;
                padding: 0 12px;
            }
            .bottom-bar {
                height: 64px;
                gap: 10px;
                padding: 0 12px;
            }
            .top-bar button,
            .bottom-bar button {
                padding: 10px 12px;
                min-width: 44px;
                justify-content: center;
            }
            .top-bar .title .title-text,
            .top-bar button .btn-label,
            .bottom-bar button .btn-label {
                display: none;
            }
        }

        /* Drag and drop overlay */
        .drag-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(59, 130, 246, 0.1);
            backdrop-filter: blur(20px);
            border: 3px dashed rgba(59, 130, 246, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .drag-overlay.active {
            display: flex;
        }

        .drag-content {
            text-align: center;
            padding: 40px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            border: 2px solid rgba(59, 130, 246, 0.5);
        }

        .drag-content i {
            font-size: 80px;
            color: #3b82f6;
            margin-bottom: 20px;
        }

        .drag-content h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .drag-content p {
            font-size: 16px;
            color: #aaa;
        }

        /* Model selection modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1e293b, #0f172a);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 20px;
            padding: 30px;
            max-width: 900px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header h2 {
            font-size: 24px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .modal-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            padding: 5px 10px;
        }

        .model-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .model-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .model-card:hover {
            border-color: rgba(59, 130, 246, 0.5);
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
        }

        .model-card.current {
            border-color: rgba(16, 185, 129, 0.8);
            background: rgba(16, 185, 129, 0.1);
        }

        .model-card.current::before {
            content: "✓ Current";
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(16, 185, 129, 0.8);
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: 600;
        }

        .model-card h3 {
            font-size: 16px;
            margin-bottom: 8px;
            color: #3b82f6;
        }

        .model-card .description {
            font-size: 13px;
            color: #aaa;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .model-card .meta {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .model-card .meta-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .model-card .download-btn {
            width: 100%;
            padding: 8px;
            background: rgba(59, 130, 246, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.5);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 13px;
            margin-top: 10px;
        }

        .model-card .download-btn:hover {
            background: rgba(59, 130, 246, 0.5);
        }

        .model-card.downloaded .download-btn {
            background: rgba(16, 185, 129, 0.2);
            border-color: rgba(16, 185, 129, 0.5);
        }

        /* Config modal */
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 14px;
        }

        .config-section {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 12px 14px;
        }

        .config-section h4 {
            font-size: 14px;
            margin-bottom: 6px;
            color: #93c5fd;
            letter-spacing: 0.3px;
        }

        .config-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin: 6px 0;
            font-size: 13px;
        }

        .config-row label {
            flex: 1 1 55%;
            color: #cbd5e1;
        }

        .config-row input,
        .config-row select {
            flex: 1 1 45%;
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            padding: 7px 8px;
            color: #fff;
            font-size: 13px;
        }

        .config-row input[type="checkbox"] {
            flex: 0 0 auto;
            width: 18px;
            height: 18px;
            accent-color: #3b82f6;
        }

        .config-subtext {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 4px;
            line-height: 1.4;
        }

        .config-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 16px;
        }

        .config-footer button {
            padding: 10px 16px;
            background: rgba(59, 130, 246, 0.25);
            border: 1px solid rgba(59, 130, 246, 0.6);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
        }

        .config-footer button.secondary {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.12);
        }

        /* Camera modal */
        .camera-modal-content {
            max-width: 900px;
        }

        .camera-layout {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
        }

        .camera-preview {
            flex: 1 1 360px;
            min-height: 260px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .camera-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #000;
        }

        .camera-controls {
            flex: 1 1 260px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .camera-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .camera-actions button,
        .camera-close-btn {
            flex: 1 1 180px;
            padding: 12px 14px;
            background: rgba(59, 130, 246, 0.25);
            border: 1px solid rgba(59, 130, 246, 0.6);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            font-size: 14px;
        }

        .camera-actions button.recording {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.6);
        }

        .camera-actions button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .camera-close-btn {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.12);
            width: 100%;
        }

        .camera-status {
            font-size: 13px;
            color: #cbd5e1;
            line-height: 1.5;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
        }

        .camera-status.info {
            color: #cbd5e1;
        }

        .camera-status.ready {
            color: #a5f3fc;
        }

        .camera-status.error {
            color: #fca5a5;
        }

        /* Status indicator */
        .status-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px 20px;
            z-index: 100;
            min-width: 250px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 13px;
        }

        .status-icon {
            font-size: 16px;
        }

        .status-loading { color: #f59e0b; }
        .status-ready { color: #10b981; }
        .status-error { color: #ef4444; }

        /* Progress bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s;
        }

        /* Hidden file input */
        #file-input {
            display: none;
        }

        .api-pill {
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            font-size: 12px;
            color: #cbd5e1;
            white-space: nowrap;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .api-pill {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Full-screen Three.js canvas -->
    <div id="canvas-container"></div>

    <!-- Top button bar -->
    <div class="top-bar">
        <div class="title">
            <i class="fas fa-cube"></i> <span class="title-text">Depth Anything 3</span>
        </div>
        <div class="api-pill" id="api-base-display"></div>
        <button onclick="showConfigModal()" id="config-btn">
            <i class="fas fa-sliders-h"></i> <span class="btn-label">Configure</span>
        </button>
        <button onclick="showModelSelector()">
            <i class="fas fa-brain"></i>
            <span id="current-model-name" class="btn-label">Select Model</span>
        </button>
        <button onclick="document.getElementById('file-input').click()">
            <i class="fas fa-folder-open"></i> <span class="btn-label">Browse Files</span>
        </button>
        <button onclick="openCameraModal()" id="camera-input-btn">
            <i class="fas fa-video"></i> <span class="btn-label">Camera</span>
        </button>
        <button onclick="loadModel()" id="load-model-btn">
            <i class="fas fa-download"></i> <span class="btn-label">Load Model</span>
        </button>
    </div>

    <!-- Bottom button bar -->
    <div class="bottom-bar">
        <!-- Video Controls (hidden by default) -->
        <div id="video-controls" style="display: none; flex: 1; max-width: 600px; margin-right: 20px;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                <button onclick="videoPlayer.play()" id="video-play-btn" style="flex: 0; min-width: 40px; padding: 8px;">
                    <i class="fas fa-play"></i>
                </button>
                <button onclick="videoPlayer.pause()" id="video-pause-btn" style="flex: 0; min-width: 40px; padding: 8px;">
                    <i class="fas fa-pause"></i>
                </button>
                <button onclick="videoPlayer.stop()" id="video-stop-btn" style="flex: 0; min-width: 40px; padding: 8px;">
                    <i class="fas fa-stop"></i>
                </button>
                <button onclick="videoPlayer.toggleLoop()" id="video-loop-btn" style="flex: 0; min-width: 40px; padding: 8px;" title="Loop">
                    <i class="fas fa-repeat"></i>
                </button>
                <button onclick="videoPlayer.toggleCameraPath()" id="video-camera-path-btn" style="flex: 0; min-width: 40px; padding: 8px;" title="Show Camera Path">
                    <i class="fas fa-video"></i>
                </button>
                <span id="frame-counter" style="color: rgba(255,255,255,0.7); font-size: 12px; white-space: nowrap;">0 / 0</span>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="frame-slider" min="0" max="0" value="0"
                       style="flex: 1; accent-color: #3b82f6;"
                       oninput="videoPlayer.seekToFrame(parseInt(this.value))">
                <span id="fps-display" style="color: rgba(255,255,255,0.5); font-size: 11px; white-space: nowrap;">15 FPS</span>
            </div>
        </div>

        <button onclick="exportGLB()" id="export-btn" disabled>
            <i class="fas fa-file-export"></i> <span class="btn-label">Export GLB</span>
        </button>
        <button onclick="alignFloor()" id="floor-btn" disabled>
            <i class="fas fa-align-center"></i> <span class="btn-label">Auto Floor</span>
        </button>
        <button onclick="toggleManualFloorSelection()" id="manual-floor-btn" disabled>
            <i class="fas fa-mouse-pointer"></i> <span id="manual-floor-text" class="btn-label">Select Floor</span>
        </button>
        <button onclick="cycleCameraMode()" id="camera-mode-btn" disabled>
            <i class="fas fa-running"></i> <span id="camera-mode-text" class="btn-label">Fly Mode</span>
        </button>
        <button onclick="resetView()" id="reset-btn" disabled>
            <i class="fas fa-undo"></i> <span class="btn-label">Reset View</span>
        </button>
    </div>

    <!-- Pointer lock activation circle -->
    <div id="pointer-lock-indicator" style="
        position: fixed;
        pointer-events: none;
        display: none;
        z-index: 10000;
    ">
        <svg width="80" height="80" style="transform: translate(-40px, -40px);">
            <circle cx="40" cy="40" r="35" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="3"/>
            <circle id="progress-circle" cx="40" cy="40" r="35" fill="none" stroke="rgba(59, 130, 246, 0.8)"
                    stroke-width="3" stroke-dasharray="220" stroke-dashoffset="220"
                    style="transform: rotate(-90deg); transform-origin: 50% 50%; transition: stroke-dashoffset 0.1s linear;"/>
            <text x="40" y="45" text-anchor="middle" fill="white" font-size="12" font-family="Arial">Hold</text>
        </svg>
    </div>

    <!-- Pointer lock exit indicator -->
    <div id="pointer-lock-active" style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        display: none;
        z-index: 10000;
    ">
        <div style="
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
        "></div>
    </div>

    <!-- Drag and drop overlay -->
    <div class="drag-overlay" id="drag-overlay">
        <div class="drag-content">
            <i class="fas fa-cloud-upload-alt"></i>
            <h2>Drop your file here</h2>
            <p>Images (JPG, PNG) or Videos (MP4, AVI, MOV)</p>
        </div>
    </div>

    <!-- Model selection modal -->
    <div class="modal" id="model-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-brain"></i> Select Model</h2>
                <button class="modal-close" onclick="closeModelSelector()">×</button>
            </div>
            <div id="model-grid" class="model-grid">
                <!-- Models will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Config modal -->
    <div class="modal" id="config-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-sliders-h"></i> Viewer & Model Config</h2>
                <button class="modal-close" onclick="closeConfigModal()">×</button>
            </div>
            <div class="config-grid">
                <div class="config-section">
                    <h4>DA3 Inference</h4>
                    <div class="config-row">
                        <label for="process-res-input">Processing Resolution</label>
                        <input type="number" id="process-res-input" min="256" max="2048" step="16" value="504">
                    </div>
                    <div class="config-row">
                        <label for="process-res-method">Resize Method</label>
                        <select id="process-res-method">
                            <option value="upper_bound_resize">upper_bound_resize</option>
                            <option value="upper_bound_crop">upper_bound_crop</option>
                            <option value="lower_bound_resize">lower_bound_resize</option>
                            <option value="lower_bound_crop">lower_bound_crop</option>
                        </select>
                    </div>
                    <div class="config-row">
                        <label for="max-points-input">Max Points</label>
                        <input type="number" id="max-points-input" min="10000" max="2000000" step="10000" value="1000000">
                    </div>
                    <div class="config-row">
                        <label for="align-scale-checkbox">Align to Input Scale</label>
                        <input type="checkbox" id="align-scale-checkbox" checked>
                    </div>
                    <div class="config-row">
                        <label for="infer-gs-checkbox">Infer Gaussian Splat</label>
                        <input type="checkbox" id="infer-gs-checkbox">
                    </div>
                    <div class="config-row">
                        <label for="export-feat-layers">Export Feature Layers</label>
                        <input type="text" id="export-feat-layers" placeholder="e.g. 0,1,2">
                    </div>
                </div>

                <div class="config-section">
                    <h4>Depth Filtering</h4>
                    <div class="config-row">
                        <label for="confidence-filter-toggle">Filter by Confidence</label>
                        <input type="checkbox" id="confidence-filter-toggle">
                    </div>
                    <div class="config-row">
                        <label for="confidence-percentile-input">Confidence Percentile</label>
                        <input type="number" id="confidence-percentile-input" min="0" max="100" step="1" value="40">
                    </div>
                    <div class="config-row">
                        <label for="include-confidence-toggle">Return Confidence</label>
                        <input type="checkbox" id="include-confidence-toggle">
                    </div>
                    <div class="config-row">
                        <label for="show-cameras-toggle">Show Cameras in Exports</label>
                        <input type="checkbox" id="show-cameras-toggle" checked>
                    </div>
                    <div class="config-row">
                        <label for="feat-vis-fps-input">Feature Vis FPS</label>
                        <input type="number" id="feat-vis-fps-input" min="1" max="60" step="1" value="15">
                    </div>
                    <div class="config-subtext">These map directly to DA3 inference options so you can drive the full library feature set.</div>
                </div>

                <div class="config-section">
                    <h4>Point Cloud Styling</h4>
                    <div class="config-row">
                        <label for="point-size-input">Point Size</label>
                        <input type="number" id="point-size-input" min="0.002" max="0.1" step="0.001" value="0.01">
                    </div>
                    <div class="config-row">
                        <label for="point-shape-select">Point Shape</label>
                        <select id="point-shape-select">
                            <option value="circle">Circle</option>
                            <option value="square">Square</option>
                        </select>
                    </div>
                    <div class="config-row">
                        <label for="mesh-toggle">Generate Mesh</label>
                        <input type="checkbox" id="mesh-toggle">
                    </div>
                    <div class="config-row">
                        <label for="mesh-sample-input">Mesh Sample Points</label>
                        <input type="number" id="mesh-sample-input" min="500" max="20000" step="500" value="3000">
                    </div>
                    <div class="config-row">
                        <label for="fill-sparse-toggle">Fill Sparse Distance Gaps</label>
                        <input type="checkbox" id="fill-sparse-toggle">
                    </div>
                    <div class="config-row">
                        <label for="fill-distance-input">Sparse Distance Threshold</label>
                        <input type="number" id="fill-distance-input" min="0.1" max="20" step="0.1" value="5">
                    </div>
                    <div class="config-row">
                        <label for="fill-neighbors-input">Neighbor Blend Count</label>
                        <input type="number" id="fill-neighbors-input" min="1" max="10" step="1" value="3">
                    </div>
                    <div class="config-row">
                        <label for="fill-newpoints-input">New Points (max)</label>
                        <input type="number" id="fill-newpoints-input" min="0" max="50000" step="500" value="5000">
                    </div>
                </div>
            </div>
            <div class="config-footer">
                <button class="secondary" onclick="resetConfigToDefaults()">Reset</button>
                <button onclick="applyConfigFromModal()">Apply</button>
            </div>
        </div>
    </div>

    <!-- Camera capture modal -->
    <div class="modal" id="camera-modal">
        <div class="modal-content camera-modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-video"></i> Camera Capture</h2>
                <button class="modal-close" onclick="closeCameraModal()">×</button>
            </div>
            <div class="camera-layout">
                <div class="camera-preview">
                    <video id="camera-preview" autoplay playsinline muted></video>
                    <canvas id="camera-canvas" style="display: none;"></canvas>
                </div>
                <div class="camera-controls">
                    <p class="camera-status info" id="camera-status">Allow camera access to capture a frame or quick video.</p>
                    <div class="camera-actions">
                        <button onclick="captureCameraFrame()" id="capture-frame-btn">
                            <i class="fas fa-camera"></i> Capture Frame
                        </button>
                        <button onclick="toggleCameraRecording()" id="record-video-btn">
                            <i class="fas fa-dot-circle"></i> Start Video
                        </button>
                    </div>
                    <button class="camera-close-btn" onclick="closeCameraModal()">
                        <i class="fas fa-times"></i> Close
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Status indicator -->
    <div class="status-indicator">
        <div class="status-item">
            <i class="fas fa-brain status-icon" id="model-status-icon"></i>
            <span id="model-status-text">Model: Not loaded</span>
        </div>
        <div class="progress-bar" id="progress-bar" style="display: none;">
            <div class="progress-fill" id="progress-fill" style="width: 0%;"></div>
        </div>
        <div class="status-item">
            <i class="fas fa-cube status-icon"></i>
            <span id="points-count">Points: 0</span>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="file-input" accept="image/*,video/*,.glb,.gltf,.json" onchange="handleFileSelect(this.files[0])">

    <script>
        // Three.js setup
        let scene, camera, renderer, controls, pointerLockControls, pointCloud;
        let flyControls = null;
        let orbitControls = null;
        let currentJobId = null;
        let currentModel = null;
        let manualFloorMode = false;
        let selectedPoints = [];
        let highlightedPoints = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let originalPointCloudData = null;  // Store original point cloud data for color restoration
        let sourcePointCloudData = null;    // Raw data from backend/upload (unmodified)
        let activePointCloudData = null;    // Data after applying viewer config transforms
        let meshObject = null;

        const defaultConfig = {
            processRes: 504,
            processResMethod: 'upper_bound_resize',
            maxPoints: 1000000,
            alignToInputScale: true,
            inferGS: false,
            exportFeatLayers: '',
            applyConfidenceFilter: false,
            confidencePercentile: 40,
            includeConfidence: false,
            showCameras: true,
            featVisFps: 15,
            pointSize: 0.01,
            pointShape: 'circle',
            generateMesh: false,
            meshSamplePoints: 3000,
            fillSparse: false,
            sparseFillDistance: 5,
            sparseFillNeighbors: 3,
            sparseFillNewPoints: 5000
        };
        let viewerConfig = {...defaultConfig};

        // Camera mode tracking
        const CAMERA_MODES = ['ORBIT', 'FLY', 'FPS'];
        const CAMERA_MODE_LABELS = {
            ORBIT: 'Orbit',
            FLY: 'Fly',
            FPS: 'FPS'
        };
        const CAMERA_MODE_STYLES = {
            ORBIT: { background: 'rgba(249, 115, 22, 0.25)', border: 'rgba(249, 115, 22, 0.6)' },
            FLY: { background: 'rgba(59, 130, 246, 0.25)', border: 'rgba(59, 130, 246, 0.6)' },
            FPS: { background: 'rgba(16, 185, 129, 0.25)', border: 'rgba(16, 185, 129, 0.6)' }
        };
        let currentCameraModeIndex = 1; // default to fly controls
        let activeCameraMode = CAMERA_MODES[currentCameraModeIndex];
        let pointerLocked = false;
        let holdStartTime = null;
        let holdTimeout = null;
        let holdAnimationFrame = null;
        let cameraYaw = 0;
        let cameraPitch = 0;
        const CAMERA_HEIGHT = 1.6;
        const WALK_SPEED = 3.5;
        const VERTICAL_SPEED = 2.0;
        const clock = new THREE.Clock();
        const tempEuler = new THREE.Euler(0, 0, 0, 'YXZ');  // used to zero roll in fly mode
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;

        function updateApiDisplay() {
            const pill = document.getElementById('api-base-display');
            if (pill) {
                pill.textContent = API_BASE || 'same-origin';
                pill.title = `Click to change API base (currently ${API_BASE || 'same-origin'})`;
            }
        }

        // Camera capture state
        let cameraStream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let shouldUploadRecording = true;
        let isRecording = false;

        function initThreeJS() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 10, 50);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.6, 5);  // Start at eye level (1.6m)

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // FlyControls (default free-fly camera)
            flyControls = new THREE.FlyControls(camera, renderer.domElement);
            flyControls.movementSpeed = 5;           // meters per second (scaled scene units)
            flyControls.rollSpeed = Math.PI / 8;     // softer roll feel
            flyControls.dragToLook = true;           // click-drag to pivot about camera position
            flyControls.autoForward = false;
            flyControls.enabled = false;

            // OrbitControls for anchor/turntable navigation
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.enablePan = true;
            orbitControls.screenSpacePanning = true;
            orbitControls.minDistance = 0.5;
            orbitControls.maxDistance = 200;
            orbitControls.enabled = false;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Axes
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // Set initial camera mode (fly)
            setCameraMode(activeCameraMode);

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Animation loop
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (isFPSMode() && pointerLocked && pointerLockControls) {
                // FPS mode movement (WASD/Arrows with pointer lock)
                const moveStep = WALK_SPEED * delta;
                const verticalStep = VERTICAL_SPEED * delta;

                if (moveForward) pointerLockControls.moveForward(moveStep);
                if (moveBackward) pointerLockControls.moveForward(-moveStep);
                if (moveLeft) pointerLockControls.moveRight(-moveStep);
                if (moveRight) pointerLockControls.moveRight(moveStep);

                const rig = pointerLockControls.getObject();
                if (moveUp) rig.position.y += verticalStep;
                if (moveDown) rig.position.y -= verticalStep;
            } else if (activeCameraMode === 'FLY') {
                if (flyControls && flyControls.enabled) {
                    flyControls.update(delta);
                    tempEuler.setFromQuaternion(camera.quaternion, 'YXZ');
                    tempEuler.z = 0;
                    camera.quaternion.setFromEuler(tempEuler);
                    camera.up.set(0, 1, 0);
                }
            } else if (activeCameraMode === 'ORBIT') {
                if (orbitControls && orbitControls.enabled) {
                    orbitControls.update();
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupDragAndDrop() {
            // Drag and drop
            document.addEventListener('dragover', (e) => {
                e.preventDefault();
                const overlay = document.getElementById('drag-overlay');
                if (overlay) overlay.classList.add('active');
            });

            document.addEventListener('dragleave', (e) => {
                if (e.target === document.body || e.target === document.documentElement) {
                    const overlay = document.getElementById('drag-overlay');
                    if (overlay) overlay.classList.remove('active');
                }
            });

            document.addEventListener('drop', (e) => {
                e.preventDefault();
                const overlay = document.getElementById('drag-overlay');
                if (overlay) overlay.classList.remove('active');

                if (e.dataTransfer.files.length > 0) {
                    handleFileSelect(e.dataTransfer.files[0]);
                }
            });
        }

        function setupKeyboardControls() {
            // Keyboard movement state tracking
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'w':
                    case 'W':
                    case 'ArrowUp':
                        moveForward = true;
                        break;
                    case 's':
                    case 'S':
                    case 'ArrowDown':
                        moveBackward = true;
                        break;
                    case 'a':
                    case 'A':
                    case 'ArrowLeft':
                        moveLeft = true;
                        break;
                    case 'd':
                    case 'D':
                    case 'ArrowRight':
                        moveRight = true;
                        break;
                    case 'q':
                    case 'Q':
                        moveUp = true;
                        break;
                    case 'e':
                    case 'E':
                        moveDown = true;
                        break;
                    case ' ':
                        if (pointerLockControls && pointerLocked) {
                            pointerLockControls.getObject().position.y = CAMERA_HEIGHT;
                        } else {
                            camera.position.y = CAMERA_HEIGHT;
                        }
                        e.preventDefault();
                        break;
                    case 'Escape':
                        if (isFPSMode()) {
                            e.preventDefault();
                            cycleCameraMode();
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.key) {
                    case 'w':
                    case 'W':
                    case 'ArrowUp':
                        moveForward = false;
                        break;
                    case 's':
                    case 'S':
                    case 'ArrowDown':
                        moveBackward = false;
                        break;
                    case 'a':
                    case 'A':
                    case 'ArrowLeft':
                        moveLeft = false;
                        break;
                    case 'd':
                    case 'D':
                    case 'ArrowRight':
                        moveRight = false;
                        break;
                    case 'q':
                    case 'Q':
                        moveUp = false;
                        break;
                    case 'e':
                    case 'E':
                        moveDown = false;
                        break;
                }
            });

            console.log('Keyboard controls enabled: WASD/Arrows=Move, Q/E=Up/Down, Space=Reset height');
        }

        function ensurePointerLockControls() {
            if (pointerLockControls) return;

            // Capture current camera transform before reparenting into controls
            const worldPos = new THREE.Vector3();
            const worldDir = new THREE.Vector3();
            camera.getWorldPosition(worldPos);
            camera.getWorldDirection(worldDir);

            pointerLockControls = new THREE.PointerLockControls(camera, renderer.domElement);
            pointerLockControls.pointerSpeed = 0.35;

            const rig = pointerLockControls.getObject();
            scene.add(rig);

            pointerLockControls.addEventListener('lock', handlePointerLockEnter);
            pointerLockControls.addEventListener('unlock', handlePointerLockExit);

            // Initialize rig orientation to match current view
            camera.position.set(0, 0, 0);
            camera.rotation.set(0, 0, 0); // clear any roll from fly mode

            cameraYaw = Math.atan2(worldDir.x, worldDir.z);
            cameraPitch = Math.asin(-worldDir.y);

            rig.position.copy(worldPos);
            rig.position.y = CAMERA_HEIGHT; // force eye height for FPS entry
            rig.rotation.y = cameraYaw;

            const pitchObject = rig.children[0];
            if (pitchObject) {
                pitchObject.rotation.x = cameraPitch;
            }
        }

        function syncPointerLockRig() {
            if (!pointerLockControls) return;

            const rig = pointerLockControls.getObject();
            const pitchObject = rig.children[0];
            const worldPos = new THREE.Vector3();
            const worldDir = new THREE.Vector3();

            camera.getWorldPosition(worldPos);
            camera.getWorldDirection(worldDir);

            cameraYaw = Math.atan2(worldDir.x, worldDir.z);
            cameraPitch = Math.asin(-worldDir.y);

            rig.position.copy(worldPos);
            rig.position.y = CAMERA_HEIGHT; // reset to FPS eye height to avoid drift
            rig.rotation.y = cameraYaw;

            if (pitchObject) {
                pitchObject.rotation.x = cameraPitch;
                pitchObject.rotation.z = 0; // remove roll from fly controls
            }

            // Clear any residual roll on the camera itself
            camera.rotation.set(0, 0, 0);
        }

        function handlePointerLockEnter() {
            pointerLocked = true;
            document.getElementById('pointer-lock-active').style.display = 'block';

            if (controls) controls.enabled = false;
            document.getElementById('model-status-text').textContent = 'First-Person Mode (ESC to exit)';
            console.log('Pointer lock activated - WASD/Arrows to move, mouse to look, ESC to exit');
        }

        function restoreCameraAfterPointerLock() {
            if (!pointerLockControls) return;

            const rig = pointerLockControls.getObject();
            const pitchObject = rig.children[0];

            const worldPos = new THREE.Vector3();
            const worldQuat = new THREE.Quaternion();
            camera.getWorldPosition(worldPos);
            camera.getWorldQuaternion(worldQuat);

            if (pitchObject && pitchObject.children.includes(camera)) {
                pitchObject.remove(camera);
            }

            scene.add(camera);
            camera.position.copy(worldPos);
            camera.quaternion.copy(worldQuat);

            scene.remove(rig);
            pointerLockControls.removeEventListener('lock', handlePointerLockEnter);
            pointerLockControls.removeEventListener('unlock', handlePointerLockExit);
            pointerLockControls.dispose();
            pointerLockControls = null;

            if (controls && !isFPSMode()) controls.enabled = true;
        }

        function handlePointerLockExit() {
            if (!pointerLocked && !pointerLockControls) return;

            pointerLocked = false;
            document.getElementById('pointer-lock-active').style.display = 'none';
            restoreCameraAfterPointerLock();

            if (isFPSMode()) {
                cycleCameraMode();
            }

            document.getElementById('model-status-text').textContent = 'Model: Ready';
            console.log('Pointer lock deactivated');
        }

        function exitPointerLock() {
            if (document.pointerLockElement) {
                document.exitPointerLock();
            } else if (pointerLocked || pointerLockControls) {
                handlePointerLockExit();
            }
        }

        function requestPointerLock() {
            if (!isFPSMode()) return;

            ensurePointerLockControls();
            syncPointerLockRig();

            if (pointerLockControls) {
                // Reset local camera rotation to align with yaw/pitch-only FPS rig
                camera.rotation.set(0, 0, 0);
                pointerLockControls.lock();
            }
        }

        function setupPointerLockControls() {
            const indicator = document.getElementById('pointer-lock-indicator');
            const progressCircle = document.getElementById('progress-circle');
            const circumference = 220; // Match stroke-dasharray

            // Start hold on mousedown (not in floor selection mode)
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 0 && !manualFloorMode && !pointerLocked && isFPSMode()) {
                    holdStartTime = Date.now();

                    // Position indicator at cursor
                    indicator.style.left = e.clientX + 'px';
                    indicator.style.top = e.clientY + 'px';
                    indicator.style.display = 'block';

                    // Animate progress circle
                    const animateProgress = () => {
                        const elapsed = Date.now() - holdStartTime;
                        const progress = Math.min(elapsed / 3000, 1); // 3 seconds
                        const offset = circumference - (progress * circumference);
                        progressCircle.style.strokeDashoffset = offset;

                        if (progress < 1) {
                            holdAnimationFrame = requestAnimationFrame(animateProgress);
                        }
                    };
                    animateProgress();

                    // Request pointer lock after 3 seconds
                    holdTimeout = setTimeout(() => {
                        indicator.style.display = 'none';
                        if (isFPSMode()) {
                            requestPointerLock();
                        }
                    }, 3000);
                }
            });

            // Cancel hold on mouseup or mouseleave
            const cancelHold = () => {
                if (holdTimeout) {
                    clearTimeout(holdTimeout);
                    holdTimeout = null;
                }
                if (holdAnimationFrame) {
                    cancelAnimationFrame(holdAnimationFrame);
                    holdAnimationFrame = null;
                }
                indicator.style.display = 'none';
                progressCircle.style.strokeDashoffset = circumference;
            };

            renderer.domElement.addEventListener('mouseup', cancelHold);
            renderer.domElement.addEventListener('mouseleave', cancelHold);

            console.log('Pointer lock controls ready: Hold mouse button for 3 seconds to activate');
        }

        function syncConfigModalFromState() {
            const setVal = (id, value) => {
                const el = document.getElementById(id);
                if (el) {
                    if (el.type === 'checkbox') {
                        el.checked = Boolean(value);
                    } else {
                        el.value = value;
                    }
                }
            };

            setVal('process-res-input', viewerConfig.processRes);
            setVal('process-res-method', viewerConfig.processResMethod);
            setVal('max-points-input', viewerConfig.maxPoints);
            setVal('align-scale-checkbox', viewerConfig.alignToInputScale);
            setVal('infer-gs-checkbox', viewerConfig.inferGS);
            setVal('export-feat-layers', viewerConfig.exportFeatLayers);
            setVal('confidence-filter-toggle', viewerConfig.applyConfidenceFilter);
            setVal('confidence-percentile-input', viewerConfig.confidencePercentile);
            setVal('include-confidence-toggle', viewerConfig.includeConfidence);
            setVal('show-cameras-toggle', viewerConfig.showCameras);
            setVal('feat-vis-fps-input', viewerConfig.featVisFps);
            setVal('point-size-input', viewerConfig.pointSize);
            setVal('point-shape-select', viewerConfig.pointShape);
            setVal('mesh-toggle', viewerConfig.generateMesh);
            setVal('mesh-sample-input', viewerConfig.meshSamplePoints);
            setVal('fill-sparse-toggle', viewerConfig.fillSparse);
            setVal('fill-distance-input', viewerConfig.sparseFillDistance);
            setVal('fill-neighbors-input', viewerConfig.sparseFillNeighbors);
            setVal('fill-newpoints-input', viewerConfig.sparseFillNewPoints);
        }

        function showConfigModal() {
            syncConfigModalFromState();
            document.getElementById('config-modal').classList.add('active');
        }

        function closeConfigModal() {
            document.getElementById('config-modal').classList.remove('active');
        }

        function applyConfigFromModal(closeAfter = true) {
            const numVal = (id, fallback) => {
                const el = document.getElementById(id);
                const parsed = parseFloat(el?.value);
                return Number.isNaN(parsed) ? fallback : parsed;
            };
            const intVal = (id, fallback) => {
                const el = document.getElementById(id);
                const parsed = parseInt(el?.value);
                return Number.isNaN(parsed) ? fallback : parsed;
            };
            const checked = (id, fallback) => {
                const el = document.getElementById(id);
                return el ? el.checked : fallback;
            };
            const textVal = (id, fallback) => {
                const el = document.getElementById(id);
                return el ? el.value : fallback;
            };

            viewerConfig.processRes = intVal('process-res-input', viewerConfig.processRes);
            viewerConfig.processResMethod = textVal('process-res-method', viewerConfig.processResMethod);
            viewerConfig.maxPoints = intVal('max-points-input', viewerConfig.maxPoints);
            viewerConfig.alignToInputScale = checked('align-scale-checkbox', viewerConfig.alignToInputScale);
            viewerConfig.inferGS = checked('infer-gs-checkbox', viewerConfig.inferGS);
            viewerConfig.exportFeatLayers = textVal('export-feat-layers', viewerConfig.exportFeatLayers);
            viewerConfig.applyConfidenceFilter = checked('confidence-filter-toggle', viewerConfig.applyConfidenceFilter);
            viewerConfig.confidencePercentile = numVal('confidence-percentile-input', viewerConfig.confidencePercentile);
            viewerConfig.includeConfidence = checked('include-confidence-toggle', viewerConfig.includeConfidence);
            viewerConfig.showCameras = checked('show-cameras-toggle', viewerConfig.showCameras);
            viewerConfig.featVisFps = intVal('feat-vis-fps-input', viewerConfig.featVisFps);
            viewerConfig.pointSize = numVal('point-size-input', viewerConfig.pointSize);
            viewerConfig.pointShape = textVal('point-shape-select', viewerConfig.pointShape);
            viewerConfig.generateMesh = checked('mesh-toggle', viewerConfig.generateMesh);
            viewerConfig.meshSamplePoints = intVal('mesh-sample-input', viewerConfig.meshSamplePoints);
            viewerConfig.fillSparse = checked('fill-sparse-toggle', viewerConfig.fillSparse);
            viewerConfig.sparseFillDistance = numVal('fill-distance-input', viewerConfig.sparseFillDistance);
            viewerConfig.sparseFillNeighbors = intVal('fill-neighbors-input', viewerConfig.sparseFillNeighbors);
            viewerConfig.sparseFillNewPoints = intVal('fill-newpoints-input', viewerConfig.sparseFillNewPoints);

            applyPointMaterialSettings();
            rebuildPointCloudWithConfig();
            if (viewerConfig.generateMesh) {
                buildMeshFromActiveCloud();
            } else {
                removeMesh();
            }

            if (closeAfter) {
                closeConfigModal();
            }
        }

        function resetConfigToDefaults() {
            viewerConfig = {...defaultConfig};
            syncConfigModalFromState();
            applyPointMaterialSettings();
            rebuildPointCloudWithConfig();
            if (viewerConfig.generateMesh) {
                buildMeshFromActiveCloud();
            } else {
                removeMesh();
            }
        }

        // Model selection
        async function showModelSelector() {
            const modal = document.getElementById('model-modal');
            modal.classList.add('active');

            // Load models
            const response = await fetch('/api/models/list');
            const data = await response.json();

            const grid = document.getElementById('model-grid');
            grid.innerHTML = '';

            data.models.forEach(model => {
                const card = document.createElement('div');
                card.className = 'model-card' + (model.current ? ' current' : '') + (model.downloaded ? ' downloaded' : '');

                // Build button HTML
                let buttonHtml = '';
                if (!model.downloaded) {
                    buttonHtml = `<button class="download-btn" onclick="selectAndDownloadModel('${model.id}')">Download & Load</button>`;
                } else if (!model.current) {
                    buttonHtml = `<button class="download-btn" onclick="selectModel('${model.id}')">Load Model</button>`;
                }

                card.innerHTML = `
                    <h3>${model.name}</h3>
                    <div class="description">${model.description}</div>
                    <div class="meta">
                        <div class="meta-item">${model.size}</div>
                        <div class="meta-item">${model.speed}</div>
                        <div class="meta-item">${model.quality}</div>
                    </div>
                    <div style="font-size: 11px; color: #888; margin-top: 5px;">
                        ${model.recommended_for}
                    </div>
                    ${buttonHtml}
                `;
                grid.appendChild(card);
            });
        }

        function closeModelSelector() {
            document.getElementById('model-modal').classList.remove('active');
        }

        async function selectModel(modelId) {
            const response = await fetch('/api/models/select', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({model_id: modelId})
            });

            if (response.ok) {
                closeModelSelector();
                updateModelStatus();
            }
        }

        async function selectAndDownloadModel(modelId) {
            await selectModel(modelId);
            await loadModel();
        }

        // Model loading
        async function loadModel() {
            try {
                const response = await fetch('/api/load_model', {method: 'POST'});
                const data = await response.json();

                if (response.ok) {
                    document.getElementById('model-status-text').textContent = 'Model: Loading...';
                    document.getElementById('model-status-icon').className = 'fas fa-spinner fa-spin status-icon status-loading';
                    document.getElementById('progress-bar').style.display = 'block';
                    const loadBtn = document.getElementById('load-model-btn');
                    if (loadBtn) {
                        loadBtn.disabled = true;
                        loadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
                    }

                    // Poll for status
                    pollModelStatus();
                } else {
                    alert('Error: ' + (data.message || data.error || 'Failed to start model loading'));
                }
            } catch (error) {
                console.error('Model loading error:', error);
                alert('Failed to load model. Check console for details.');
            }
        }

        async function pollModelStatus() {
            const interval = setInterval(async () => {
                const response = await fetch('/api/model_status');
                const data = await response.json();

                document.getElementById('progress-fill').style.width = data.progress + '%';

                if (data.status === 'ready') {
                    clearInterval(interval);
                    applyModelStatus(data);
                }
            }, 2000);
        }

        function applyModelStatus(statusData, currentModelName = null) {
            const textEl = document.getElementById('model-status-text');
            const iconEl = document.getElementById('model-status-icon');
            const progressBar = document.getElementById('progress-bar');
            const loadBtn = document.getElementById('load-model-btn');

            const setButtonsEnabled = (enabled) => {
                ['export-btn', 'floor-btn', 'manual-floor-btn', 'camera-mode-btn', 'reset-btn'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.disabled = !enabled;
                });
            };

            if (statusData.status === 'ready') {
                textEl.textContent = 'Model: Ready';
                iconEl.className = 'fas fa-check-circle status-icon status-ready';
                progressBar.style.display = 'none';
                setButtonsEnabled(true);
                if (loadBtn) {
                    loadBtn.disabled = true;
                    loadBtn.innerHTML = '<i class="fas fa-check-circle"></i> Model Loaded';
                }
            } else if (statusData.status === 'loading') {
                textEl.textContent = 'Model: Loading...';
                iconEl.className = 'fas fa-spinner fa-spin status-icon status-loading';
                progressBar.style.display = 'block';
                setButtonsEnabled(false);
                if (loadBtn) {
                    loadBtn.disabled = true;
                    loadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
                }
            } else {
                textEl.textContent = 'Model: Not loaded';
                iconEl.className = 'fas fa-brain status-icon';
                progressBar.style.display = 'none';
                setButtonsEnabled(false);
                if (loadBtn) {
                    loadBtn.disabled = false;
                    loadBtn.innerHTML = '<i class="fas fa-download"></i> Load Model';
                }
            }

            if (currentModelName) {
                document.getElementById('current-model-name').textContent = currentModelName;
            }
        }

        async function updateModelStatus() {
            const response = await fetch('/api/models/list');
            const data = await response.json();
            const current = data.models.find(m => m.current);
            if (current) {
                document.getElementById('current-model-name').textContent = current.name;
            }
            return current;
        }

        async function hydrateModelStatus() {
            try {
                const [statusRes, modelsRes] = await Promise.all([
                    fetch('/api/model_status'),
                    fetch('/api/models/list')
                ]);
                const statusData = await statusRes.json();
                const modelsData = await modelsRes.json();
                const current = modelsData.models.find(m => m.current);
                applyModelStatus(statusData, current ? current.name : null);
            } catch (err) {
                console.error('Failed to hydrate model status', err);
            }
        }

        // Camera capture (upload frame or quick video)
        async function openCameraModal() {
            document.getElementById('camera-modal').classList.add('active');
            updateRecordButton(false);
            await ensureCameraStream();
        }

        async function ensureCameraStream() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                setCameraStatus('Camera access is not supported in this browser.', 'error');
                return null;
            }

            if (cameraStream) {
                setCameraStatus('Camera ready. Capture a frame or record a clip.', 'ready');
                return cameraStream;
            }

            setCameraStatus('Requesting camera access...');
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' },
                    audio: false
                });

                const preview = document.getElementById('camera-preview');
                if (preview) {
                    preview.srcObject = cameraStream;
                    await preview.play();
                }

                setCameraStatus('Camera ready. Capture a frame or record a clip.', 'ready');

                cameraStream.getVideoTracks().forEach(track => {
                    track.onended = () => {
                        const modal = document.getElementById('camera-modal');
                        if (modal && modal.classList.contains('active')) {
                            stopCameraStream();
                            setCameraStatus('Camera disconnected. Reopen to request access again.', 'error');
                        }
                    };
                });

                return cameraStream;
            } catch (err) {
                console.error('Camera access error', err);
                setCameraStatus('Unable to access the camera. Please check permissions and try again.', 'error');
                return null;
            }
        }

        function setCameraStatus(message, state = 'info') {
            const status = document.getElementById('camera-status');
            if (!status) return;
            status.textContent = message;
            status.classList.remove('ready', 'error', 'info');
            if (state) {
                status.classList.add(state);
            }
        }

        function stopCameraStream() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            const preview = document.getElementById('camera-preview');
            if (preview) {
                preview.pause();
                preview.srcObject = null;
            }
        }

        function closeCameraModal() {
            document.getElementById('camera-modal').classList.remove('active');
            stopCameraRecording(true);
            stopCameraStream();
            setCameraStatus('Allow camera access to capture a frame or quick video.', 'info');
        }

        async function captureCameraFrame() {
            if (isRecording) {
                setCameraStatus('Stop recording before capturing a frame.', 'error');
                return;
            }

            const stream = await ensureCameraStream();
            if (!stream) return;

            const video = document.getElementById('camera-preview');
            const canvas = document.getElementById('camera-canvas');
            const width = video.videoWidth || 1280;
            const height = video.videoHeight || 720;

            if (!width || !height) {
                setCameraStatus('Camera is warming up... try again in a second.', 'error');
                return;
            }

            canvas.width = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, width, height);

            canvas.toBlob((blob) => {
                if (!blob) {
                    setCameraStatus('Failed to capture frame. Try again.', 'error');
                    return;
                }
                const file = new File([blob], `camera-frame-${Date.now()}.png`, { type: 'image/png' });
                setCameraStatus('Uploading frame...', 'ready');
                handleFileSelect(file);
                closeCameraModal();
            }, 'image/png');
        }

        function updateRecordButton(recording) {
            const recordBtn = document.getElementById('record-video-btn');
            const captureBtn = document.getElementById('capture-frame-btn');
            if (!recordBtn) return;

            if (recording) {
                recordBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Video';
                recordBtn.classList.add('recording');
                if (captureBtn) captureBtn.disabled = true;
            } else {
                recordBtn.innerHTML = '<i class="fas fa-dot-circle"></i> Start Video';
                recordBtn.classList.remove('recording');
                if (captureBtn) captureBtn.disabled = false;
            }
        }

        function stopCameraRecording(skipUpload = false) {
            if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                isRecording = false;
                updateRecordButton(false);
                return;
            }

            shouldUploadRecording = !skipUpload;
            try {
                mediaRecorder.stop();
            } catch (err) {
                console.warn('Failed to stop recording cleanly', err);
            }
            isRecording = false;
            updateRecordButton(false);
            if (skipUpload) {
                recordedChunks = [];
            }
        }

        function startCameraRecording() {
            if (!cameraStream) {
                setCameraStatus('Please allow camera access before recording.', 'error');
                return;
            }
            if (typeof MediaRecorder === 'undefined') {
                setCameraStatus('Recording is not supported in this browser.', 'error');
                return;
            }

            recordedChunks = [];
            shouldUploadRecording = true;

            const options = {};
            if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                options.mimeType = 'video/webm;codecs=vp9';
            } else if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                options.mimeType = 'video/webm;codecs=vp8';
            }

            try {
                mediaRecorder = new MediaRecorder(cameraStream, options);
            } catch (err) {
                console.error('Failed to start recorder', err);
                setCameraStatus('Unable to start recording. Try a different browser.', 'error');
                return;
            }

            mediaRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const mimeType = (options && options.mimeType) || (recordedChunks[0] && recordedChunks[0].type) || 'video/webm';
                const blob = new Blob(recordedChunks, { type: mimeType });
                if (!blob.size || !shouldUploadRecording) {
                    recordedChunks = [];
                    return;
                }

                const file = new File([blob], `camera-recording-${Date.now()}.webm`, { type: blob.type || 'video/webm' });
                recordedChunks = [];
                setCameraStatus('Uploading recording...', 'ready');
                handleFileSelect(file);
                closeCameraModal();
            };

            mediaRecorder.start();
            isRecording = true;
            updateRecordButton(true);
            setCameraStatus('Recording... click stop when ready.', 'ready');
        }

        async function toggleCameraRecording() {
            if (isRecording) {
                stopCameraRecording(false);
                return;
            }

            const stream = await ensureCameraStream();
            if (!stream) return;

            startCameraRecording();
        }

        // File processing (images/videos go to backend; GLB/GLTF/JSON load locally)
        async function handleFileSelect(file) {
            if (!file) return;
            const lowerName = file.name.toLowerCase();
            const isLocalPointCloud = lowerName.endsWith('.glb') || lowerName.endsWith('.gltf') || lowerName.endsWith('.json');

            if (isLocalPointCloud) {
                loadLocalGLB(file);
                return;
            }

            // Otherwise: send to backend for inference
            // Check if model is ready
            const statusResponse = await fetch('/api/model_status');
            const statusData = await statusResponse.json();

            if (statusData.status !== 'ready') {
                alert('Please load a model first by clicking "Select Model" and then "Load Model"');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('resolution', viewerConfig.processRes);
            formData.append('max_points', viewerConfig.maxPoints);
            formData.append('process_res_method', viewerConfig.processResMethod);
            formData.append('align_to_input_ext_scale', viewerConfig.alignToInputScale);
            formData.append('infer_gs', viewerConfig.inferGS);
            formData.append('export_feat_layers', viewerConfig.exportFeatLayers);
            formData.append('conf_thresh_percentile', viewerConfig.confidencePercentile);
            formData.append('apply_confidence_filter', viewerConfig.applyConfidenceFilter);
            formData.append('include_confidence', viewerConfig.includeConfidence);
            formData.append('show_cameras', viewerConfig.showCameras);
            formData.append('feat_vis_fps', viewerConfig.featVisFps);

            document.getElementById('model-status-text').textContent = 'Uploading...';

            try {
                const response = await fetch('/api/process', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok && data.pointcloud) {
                    // Direct load (e.g., server-side GLB/JSON upload bypassing inference)
                    loadPointCloud(data.pointcloud);
                    document.getElementById('model-status-text').textContent = 'Model: Ready';
                    document.getElementById('export-btn').disabled = false;
                    document.getElementById('floor-btn').disabled = false;
                    document.getElementById('manual-floor-btn').disabled = false;
                    document.getElementById('camera-mode-btn').disabled = false;
                    document.getElementById('reset-btn').disabled = false;
                    return;
                } else if (response.ok && data.job_id) {
                    currentJobId = data.job_id;
                    document.getElementById('model-status-text').textContent = 'Processing...';
                    pollJobStatus();
                } else {
                    alert('Error: ' + (data.error || 'Unknown error'));
                    document.getElementById('model-status-text').textContent = 'Model: Ready';
                }
            } catch (error) {
                console.error('Upload error:', error);
                alert('Failed to upload file. Check console for details.');
                document.getElementById('model-status-text').textContent = 'Model: Ready';
            }
        }

        function loadLocalGLB(file) {
            document.getElementById('model-status-text').textContent = 'Loading local point cloud...';
            const loader = new THREE.GLTFLoader();
            const url = URL.createObjectURL(file);

            loader.load(url, (gltf) => {
                // Remove existing point cloud
                if (pointCloud) {
                    scene.remove(pointCloud);
                    pointCloud = null;
                }
                removeMesh();

                let loadedPoints = null;
                let numPoints = 0;

                // Simply find the Points object in the scene and use it directly
                gltf.scene.traverse((child) => {
                    if (child.isPoints) {
                        loadedPoints = child;
                        // Ensure material has proper settings for vertex colors
                        if (child.material) {
                            child.material.vertexColors = true;
                            child.material.size = child.material.size || 0.01;
                            child.material.needsUpdate = true;
                        }
                        if (child.geometry && child.geometry.attributes.position) {
                            numPoints = child.geometry.attributes.position.count;
                        }
                    }
                });

                // If no Points object found, try to use the whole scene
                if (!loadedPoints) {
                    loadedPoints = gltf.scene;
                    gltf.scene.traverse((child) => {
                        if (child.geometry && child.geometry.attributes.position) {
                            numPoints += child.geometry.attributes.position.count;
                        }
                    });
                }

                // Add the loaded GLB directly to the scene
                pointCloud = loadedPoints;
                scene.add(pointCloud);

                document.getElementById('points-count').textContent = `Points: ${numPoints.toLocaleString()}`;
                document.getElementById('model-status-text').textContent = 'Model: Ready';
                document.getElementById('export-btn').disabled = false;
                document.getElementById('floor-btn').disabled = false;
                document.getElementById('manual-floor-btn').disabled = false;
                document.getElementById('camera-mode-btn').disabled = false;
                document.getElementById('reset-btn').disabled = false;

                URL.revokeObjectURL(url);
            }, undefined, (err) => {
                console.error('GLB load error:', err);
                alert('Failed to load GLB. See console for details.');
                document.getElementById('model-status-text').textContent = 'Model: Ready';
                URL.revokeObjectURL(url);
            });
        }

        async function pollJobStatus() {
            const interval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/job/${currentJobId}`);
                    const data = await response.json();

                    if (data.status === 'completed') {
                        clearInterval(interval);
                        loadPointCloud(data.pointcloud);
                        document.getElementById('model-status-text').textContent = 'Model: Ready';
                        document.getElementById('export-btn').disabled = false;
                        document.getElementById('floor-btn').disabled = false;
                        document.getElementById('manual-floor-btn').disabled = false;
                        document.getElementById('camera-mode-btn').disabled = false;
                        document.getElementById('reset-btn').disabled = false;
                    } else if (data.status === 'error') {
                        clearInterval(interval);
                        alert('Processing failed: ' + (data.error || 'Unknown error'));
                        document.getElementById('model-status-text').textContent = 'Model: Ready';
                    }
                } catch (error) {
                    console.error('Status polling error:', error);
                }
            }, 1000);
        }

        function applyConfigToPointCloudData(rawData) {
            if (!rawData) return null;
            if (!viewerConfig.fillSparse) {
                return rawData;
            }
            return densifyPointCloudData(rawData);
        }

        function densifyPointCloudData(rawData) {
            const baseVertices = (rawData.vertices || []).slice();
            if (!baseVertices.length) return rawData;

            const baseColors = (
                rawData.colors && rawData.colors.length
                    ? rawData.colors.slice()
                    : baseVertices.map(() => [255, 255, 255])
            );

            const farIndices = [];
            const targetDistance = Math.max(0.1, viewerConfig.sparseFillDistance);
            baseVertices.forEach((v, idx) => {
                const dist = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
                if (dist > targetDistance) farIndices.push(idx);
            });

            if (!farIndices.length || viewerConfig.sparseFillNewPoints <= 0) {
                return rawData;
            }

            const newVertices = baseVertices.slice();
            const newColors = baseColors.slice();
            const sampleCount = Math.min(viewerConfig.sparseFillNewPoints, farIndices.length);

            for (let i = 0; i < sampleCount; i++) {
                const anchorIdx = farIndices[Math.floor(Math.random() * farIndices.length)];
                const neighborIndices = [];
                const neighborTotal = Math.max(1, viewerConfig.sparseFillNeighbors);
                for (let n = 0; n < neighborTotal; n++) {
                    neighborIndices.push(farIndices[Math.floor(Math.random() * farIndices.length)]);
                }

                const anchor = baseVertices[anchorIdx];
                const neighborAvg = neighborIndices.reduce((acc, idx) => {
                    const v = baseVertices[idx];
                    acc[0] += v[0];
                    acc[1] += v[1];
                    acc[2] += v[2];
                    return acc;
                }, [0, 0, 0]).map(sum => sum / neighborIndices.length);

                const newPoint = [
                    (anchor[0] + neighborAvg[0]) / 2,
                    (anchor[1] + neighborAvg[1]) / 2,
                    (anchor[2] + neighborAvg[2]) / 2
                ];

                const anchorColor = baseColors[anchorIdx] || [255, 255, 255];
                const neighborColor = neighborIndices.reduce((acc, idx) => {
                    const c = baseColors[idx] || [255, 255, 255];
                    acc[0] += c[0];
                    acc[1] += c[1];
                    acc[2] += c[2];
                    return acc;
                }, [0, 0, 0]).map(sum => sum / neighborIndices.length);

                const newColor = [
                    (anchorColor[0] + neighborColor[0]) / 2,
                    (anchorColor[1] + neighborColor[1]) / 2,
                    (anchorColor[2] + neighborColor[2]) / 2
                ];

                newVertices.push(newPoint);
                newColors.push(newColor);
            }

            return {
                vertices: newVertices,
                colors: newColors,
                metadata: {
                    ...(rawData.metadata || {}),
                    num_points: newVertices.length,
                    dense_fill: true
                }
            };
        }

        function createPointsMaterial() {
            const material = new THREE.PointsMaterial({
                size: viewerConfig.pointSize,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                depthWrite: false
            });

            material.onBeforeCompile = (shader) => {
                if (viewerConfig.pointShape === 'circle') {
                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <alphatest_fragment>',
                        'if (length(gl_PointCoord - 0.5) > 0.5) discard;\n#include <alphatest_fragment>'
                    );
                }
            };
            material.needsUpdate = true;
            return material;
        }

        function applyPointMaterialSettings() {
            if (!pointCloud || !pointCloud.material) return;
            const oldMaterial = pointCloud.material;
            const newMaterial = createPointsMaterial();
            pointCloud.material = newMaterial;
            if (oldMaterial.dispose) oldMaterial.dispose();
        }

        function removeMesh() {
            if (meshObject) {
                scene.remove(meshObject);
                if (meshObject.geometry) meshObject.geometry.dispose();
                if (meshObject.material && meshObject.material.dispose) {
                    meshObject.material.dispose();
                }
                meshObject = null;
            }
        }

        function buildMeshFromActiveCloud() {
            if (!viewerConfig.generateMesh || !activePointCloudData) return;
            removeMesh();

            const vertices = activePointCloudData.vertices || [];
            if (!vertices.length) return;

            const baseColors = (
                activePointCloudData.colors && activePointCloudData.colors.length
                    ? activePointCloudData.colors
                    : vertices.map(() => [255, 255, 255])
            );

            const sampleCap = 5000;
            const sampleCount = Math.min(
                Math.max(500, viewerConfig.meshSamplePoints),
                Math.min(vertices.length, sampleCap)
            );
            const sampleIndices = new Set();
            while (sampleIndices.size < sampleCount) {
                sampleIndices.add(Math.floor(Math.random() * vertices.length));
            }

            const points = [];
            const colors = [];
            sampleIndices.forEach((idx) => {
                const v = vertices[idx];
                const c = baseColors[idx] || [255, 255, 255];
                points.push(new THREE.Vector3(v[0], v[1], v[2]));
                colors.push([c[0] / 255, c[1] / 255, c[2] / 255]);
            });

            const neighborCount = Math.min(10, points.length - 1);
            const neighborMap = [];
            for (let i = 0; i < points.length; i++) {
                const center = points[i];
                const distances = [];
                for (let j = 0; j < points.length; j++) {
                    if (i === j) continue;
                    const dist = center.distanceToSquared(points[j]);
                    distances.push({ j, dist });
                }
                distances.sort((a, b) => a.dist - b.dist);
                neighborMap[i] = distances.slice(0, neighborCount).map(d => d.j);
            }

            const indices = [];
            const triKeys = new Set();

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const neighbors = neighborMap[i];
                if (neighbors.length < 2) continue;

                const v1 = points[neighbors[0]].clone().sub(p);
                const v2 = points[neighbors[1]].clone().sub(p);
                const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                if (normal.lengthSq() < 1e-6) {
                    normal.set(0, 1, 0);
                }

                const u = Math.abs(normal.x) < 0.9
                    ? new THREE.Vector3(1, 0, 0).cross(normal).normalize()
                    : new THREE.Vector3(0, 1, 0).cross(normal).normalize();
                const v = new THREE.Vector3().crossVectors(normal, u);

                const ordered = neighbors.map(idx => {
                    const rel = points[idx].clone().sub(p);
                    const proj = rel.sub(normal.clone().multiplyScalar(rel.dot(normal)));
                    const angle = Math.atan2(proj.dot(v), proj.dot(u));
                    return { idx, angle };
                }).sort((a, b) => a.angle - b.angle);

                for (let t = 0; t < ordered.length; t++) {
                    const a = ordered[t].idx;
                    const b = ordered[(t + 1) % ordered.length].idx;
                    if (a === b || a === i || b === i) continue;
                    const key = [i, a, b].sort((x, y) => x - y).join('-');
                    if (triKeys.has(key)) continue;
                    triKeys.add(key);
                    indices.push(i, a, b);
                }
            }

            if (indices.length === 0) return;

            const geometry = new THREE.BufferGeometry();
            const positionArray = new Float32Array(points.length * 3);
            const colorArray = new Float32Array(points.length * 3);
            for (let i = 0; i < points.length; i++) {
                positionArray[i * 3] = points[i].x;
                positionArray[i * 3 + 1] = points[i].y;
                positionArray[i * 3 + 2] = points[i].z;
                colorArray[i * 3] = colors[i][0];
                colorArray[i * 3 + 1] = colors[i][1];
                colorArray[i * 3 + 2] = colors[i][2];
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                flatShading: false,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });

            meshObject = new THREE.Mesh(geometry, material);
            scene.add(meshObject);
        }

        function rebuildPointCloudWithConfig() {
            if (!sourcePointCloudData) return;
            loadPointCloud(sourcePointCloudData, {preserveSource: true});
        }

        function colorAttrToByteTriplets(attr) {
            if (!attr) return [];
            const colors = [];
            let maxVal = 0;
            for (let i = 0; i < attr.count; i++) {
                const r = attr.getX(i) || 0;
                const g = attr.getY(i) || 0;
                const b = attr.getZ(i) || 0;
                maxVal = Math.max(maxVal, r, g, b);
                colors.push([r, g, b]);
            }
            const needsUpscale = attr.normalized || maxVal <= 1.01;
            if (needsUpscale) {
                for (let i = 0; i < colors.length; i++) {
                    colors[i] = colors[i].map(v => v * 255);
                }
            }
            return colors;
        }

        function textureToColors(geometry, texture) {
            if (!geometry || !texture || !texture.image || !geometry.attributes.uv) return [];
            const img = texture.image;
            const uvAttr = geometry.attributes.uv;
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            const colors = new Array(uvAttr.count);
            const w = canvas.width;
            const h = canvas.height;
            for (let i = 0; i < uvAttr.count; i++) {
                const u = uvAttr.getX(i);
                const v = uvAttr.getY(i);
                const px = Math.min(w - 1, Math.max(0, Math.floor(u * (w - 1))));
                const py = Math.min(h - 1, Math.max(0, Math.floor((1 - v) * (h - 1))));
                const idx = (py * w + px) * 4;
                colors[i] = [data[idx], data[idx + 1], data[idx + 2]];
            }
            return colors;
        }

        function extractColorsFromGeometry(geometry, material) {
            if (!geometry || !geometry.attributes?.position) return [];

            const colorAttr = geometry.attributes.color;
            if (colorAttr && colorAttr.count) {
                return colorAttrToByteTriplets(colorAttr);
            }

            if (material && material.map) {
                const texColors = textureToColors(geometry, material.map);
                if (texColors.length) return texColors;
            }

            if (material && material.color) {
                const c = material.color;
                const count = geometry.attributes.position.count;
                return new Array(count).fill([c.r * 255, c.g * 255, c.b * 255]);
            }

            return [];
        }

        function injectTextureVertexColors(geometry, material) {
            if (!geometry || !material || !material.map || geometry.attributes.color) return;
            const uvAttr = geometry.attributes.uv;
            if (!uvAttr) return;
            const img = material.map.image;
            if (!img || !img.width || !img.height) return;

            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

            const colors = new Float32Array(uvAttr.count * 3);
            const w = canvas.width;
            const h = canvas.height;

            for (let i = 0; i < uvAttr.count; i++) {
                const u = uvAttr.getX(i);
                const v = uvAttr.getY(i);
                const px = Math.min(w - 1, Math.max(0, Math.floor(u * (w - 1))));
                const py = Math.min(h - 1, Math.max(0, Math.floor((1 - v) * (h - 1))));
                const idx = (py * w + px) * 4;
                colors[i * 3] = data[idx] / 255;
                colors[i * 3 + 1] = data[idx + 1] / 255;
                colors[i * 3 + 2] = data[idx + 2] / 255;
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        }

        function loadPointCloud(data, options = {}) {
            const { preserveSource = false } = options;
            try {
                const shouldUpdateSource = !preserveSource || !sourcePointCloudData;
                if (shouldUpdateSource) {
                    sourcePointCloudData = data;
                }

                const workingSource = preserveSource ? (sourcePointCloudData || data) : data;
                const processed = applyConfigToPointCloudData(workingSource);
                if (!processed.metadata) {
                    processed.metadata = {};
                }
                if (!processed.metadata.num_points) {
                    processed.metadata.num_points = processed.vertices.length;
                }
                activePointCloudData = processed;
                originalPointCloudData = processed;

                // Remove existing point cloud
                if (pointCloud) {
                    scene.remove(pointCloud);
                    if (pointCloud.geometry) pointCloud.geometry.dispose();
                    if (pointCloud.material && pointCloud.material.dispose) {
                        pointCloud.material.dispose();
                    }
                }

                removeMesh();

                // Create geometry
                const geometry = new THREE.BufferGeometry();
                const vertices = new Float32Array(processed.vertices.flat());
                const normalizedColorsSource = (
                    processed.colors && processed.colors.length
                        ? processed.colors
                        : processed.vertices.map(() => [255, 255, 255])
                );
                if (!processed.colors || !processed.colors.length) {
                    processed.colors = normalizedColorsSource;
                }
                const colors = new Float32Array(normalizedColorsSource.flat().map(c => c / 255));

                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                // Create material
                const material = createPointsMaterial();

                // Create point cloud
                pointCloud = new THREE.Points(geometry, material);
                scene.add(pointCloud);

                // Update stats
                const numPoints = processed.metadata?.num_points || processed.vertices.length;
                document.getElementById('points-count').textContent = `Points: ${numPoints.toLocaleString()}`;
                document.getElementById('model-status-text').textContent = 'Model: Ready';
                document.getElementById('export-btn').disabled = false;
                document.getElementById('floor-btn').disabled = false;
                document.getElementById('manual-floor-btn').disabled = false;
                document.getElementById('camera-mode-btn').disabled = false;
                document.getElementById('reset-btn').disabled = false;

                // Check if this is a video and load video player
                if (processed.metadata?.is_video) {
                    console.log('Video detected, loading video player...');
                    setTimeout(async () => {
                        const loaded = await videoPlayer.loadVideo();
                        if (loaded) {
                            console.log('Video player initialized successfully');
                        }
                    }, 500);
                } else {
                    // Hide video controls if showing
                    videoPlayer.reset();
                }

                // Center camera
                const box = new THREE.Box3().setFromObject(pointCloud);
                const center = box.getCenter(new THREE.Vector3());
                camera.lookAt(center);
                if (controls) controls.update(0);

                hydrateModelStatus();
                if (viewerConfig.generateMesh) {
                    buildMeshFromActiveCloud();
                }

                console.log('Point cloud loaded successfully');
            } catch (error) {
                console.error('Error loading point cloud:', error);
                alert('Failed to load point cloud. Check console for details.');
            }
        }

        // Floor alignment (automatic)
        async function alignFloor() {
            try {
                document.getElementById('model-status-text').textContent = 'Aligning floor...';
                const response = await fetch('/api/floor_align', {method: 'POST'});
                const data = await response.json();

                if (response.ok) {
                    loadPointCloud(data.pointcloud);
                    alert('Floor aligned successfully! The floor is now at y=0.');
                    document.getElementById('model-status-text').textContent = 'Model: Ready';
                } else {
                    alert('Error: ' + (data.error || 'Failed to align floor'));
                    document.getElementById('model-status-text').textContent = 'Model: Ready';
                }
            } catch (error) {
                console.error('Floor alignment error:', error);
                alert('Failed to align floor. Check console for details.');
                document.getElementById('model-status-text').textContent = 'Model: Ready';
            }
        }

        // Manual floor selection
        function toggleManualFloorSelection() {
            manualFloorMode = !manualFloorMode;
            const btn = document.getElementById('manual-floor-btn');
            const text = document.getElementById('manual-floor-text');

            if (manualFloorMode) {
                btn.style.background = 'rgba(59, 130, 246, 0.5)';
                btn.style.borderColor = 'rgba(59, 130, 246, 0.8)';
                text.textContent = 'Click Floor';
                document.getElementById('model-status-text').textContent = 'Click on floor surface...';
                console.log('Manual floor selection mode: ON');
            } else {
                btn.style.background = 'rgba(16, 185, 129, 0.2)';
                btn.style.borderColor = 'rgba(16, 185, 129, 0.5)';
                text.textContent = 'Select Floor';
                document.getElementById('model-status-text').textContent = 'Model: Ready';
                clearHighlightedPoints();
                selectedPoints = [];
                console.log('Manual floor selection mode: OFF');
            }
        }

        function onMouseClick(event) {
            if (!manualFloorMode || !pointCloud) return;

            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update raycaster
            raycaster.setFromCamera(mouse, camera);

            // Check for intersections
            const intersects = raycaster.intersectObject(pointCloud, true);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const point = intersect.point;

                console.log('Clicked point:', point);

                // Find nearby points
                findNearbyPoints(point);

                // Fit plane and align
                if (selectedPoints.length > 100) {
                    applyManualFloorAlignment();
                }
            }
        }

        function findNearbyPoints(clickedPoint) {
            if (!pointCloud) return;

            const positions = pointCloud.geometry.attributes.position.array;
            const colors = pointCloud.geometry.attributes.color.array;

            const searchRadius = 0.5;  // 0.5 meter radius
            const nearby = [];
            const nearbyIndices = [];

            // Find all points within radius
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];

                const dx = x - clickedPoint.x;
                const dy = y - clickedPoint.y;
                const dz = z - clickedPoint.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (distance < searchRadius) {
                    nearby.push(new THREE.Vector3(x, y, z));
                    nearbyIndices.push(i / 3);
                }
            }

            selectedPoints = nearby;

            console.log(`Found ${nearby.length} nearby points within ${searchRadius}m`);

            // Highlight selected points
            highlightPoints(nearbyIndices, colors);
        }

        function highlightPoints(indices, originalColors) {
            if (!pointCloud) return;

            const colors = pointCloud.geometry.attributes.color.array;

            // Reset all colors first
            for (let i = 0; i < colors.length; i++) {
                colors[i] = originalColors[i];
            }

            // Highlight selected points (white)
            indices.forEach(idx => {
                colors[idx * 3] = 1.0;      // R
                colors[idx * 3 + 1] = 1.0;  // G
                colors[idx * 3 + 2] = 1.0;  // B
            });

            pointCloud.geometry.attributes.color.needsUpdate = true;

            document.getElementById('model-status-text').textContent =
                `Selected ${indices.length} points. Processing...`;
        }

        function clearHighlightedPoints() {
            if (!pointCloud || !originalPointCloudData) return;

            const colors = pointCloud.geometry.attributes.color.array;
            const originalColors = originalPointCloudData.colors;
            if (!originalColors || !originalColors.length) return;
            const limit = Math.min(originalColors.length, colors.length / 3);

            // Restore original colors
            for (let i = 0; i < limit; i++) {
                for (let j = 0; j < 3; j++) {
                    colors[i * 3 + j] = originalColors[i][j] / 255;
                }
            }

            pointCloud.geometry.attributes.color.needsUpdate = true;
            console.log('Original colors restored');
        }

        function fitPlaneToPoints(points) {
            // Fit plane using least squares
            // Plane equation: ax + by + cz + d = 0

            const n = points.length;
            if (n < 3) return null;

            // Calculate centroid
            const centroid = new THREE.Vector3();
            points.forEach(p => centroid.add(p));
            centroid.divideScalar(n);

            // Build covariance matrix
            let xx = 0, xy = 0, xz = 0;
            let yy = 0, yz = 0, zz = 0;

            points.forEach(p => {
                const dx = p.x - centroid.x;
                const dy = p.y - centroid.y;
                const dz = p.z - centroid.z;

                xx += dx * dx;
                xy += dx * dy;
                xz += dx * dz;
                yy += dy * dy;
                yz += dy * dz;
                zz += dz * dz;
            });

            // Find eigenvector corresponding to smallest eigenvalue
            // Simplified: assume normal is mostly vertical
            // Use cross product of two vectors in the plane

            // Get two vectors from centroid to sample points
            const v1 = new THREE.Vector3().subVectors(points[0], centroid);
            const v2 = new THREE.Vector3().subVectors(points[Math.floor(n/2)], centroid);

            // Normal is cross product
            const normal = new THREE.Vector3().crossVectors(v1, v2);
            normal.normalize();

            // Ensure normal points upward
            if (normal.y < 0) {
                normal.multiplyScalar(-1);
            }

            // Calculate d coefficient
            const d = -normal.dot(centroid);

            return { normal, d, centroid };
        }

        function applyManualFloorAlignment() {
            if (selectedPoints.length < 100) {
                alert('Not enough points selected. Click on a larger floor area.');
                return;
            }

            document.getElementById('model-status-text').textContent = 'Fitting plane...';

            // Fit plane to selected points
            const plane = fitPlaneToPoints(selectedPoints);

            if (!plane) {
                alert('Failed to fit plane to selected points.');
                document.getElementById('model-status-text').textContent = 'Model: Ready';
                return;
            }

            console.log('Fitted plane normal:', plane.normal);
            console.log('Plane centroid:', plane.centroid);

            // Create rotation to align plane with XZ (y=0)
            const targetNormal = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(plane.normal, targetNormal);

            // Apply rotation to all points
            const positions = pointCloud.geometry.attributes.position.array;
            const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);

            for (let i = 0; i < positions.length; i += 3) {
                const point = new THREE.Vector3(
                    positions[i],
                    positions[i + 1],
                    positions[i + 2]
                );

                point.applyMatrix4(rotationMatrix);

                positions[i] = point.x;
                positions[i + 1] = point.y;
                positions[i + 2] = point.z;
            }

            // Find lowest point and translate to y=0
            let minY = Infinity;
            for (let i = 1; i < positions.length; i += 3) {
                if (positions[i] < minY) minY = positions[i];
            }

            for (let i = 1; i < positions.length; i += 3) {
                positions[i] -= minY;
            }

            pointCloud.geometry.attributes.position.needsUpdate = true;
            pointCloud.geometry.computeBoundingSphere();

            // Update stored point cloud data with new aligned vertices
            const newVertices = [];
            for (let i = 0; i < positions.length; i += 3) {
                newVertices.push([positions[i], positions[i + 1], positions[i + 2]]);
            }

            if (originalPointCloudData) {
                originalPointCloudData.vertices = newVertices;
            }
            if (activePointCloudData) {
                activePointCloudData.vertices = newVertices;
                if (activePointCloudData.metadata) {
                    activePointCloudData.metadata.num_points = newVertices.length;
                }
            }
            if (sourcePointCloudData) {
                sourcePointCloudData.vertices = newVertices;
                if (sourcePointCloudData.metadata) {
                    sourcePointCloudData.metadata.num_points = newVertices.length;
                }
            }

            // Exit selection mode (this will restore original colors)
            toggleManualFloorSelection();

            alert(`Floor aligned! Used ${selectedPoints.length} points for plane fitting.`);
            document.getElementById('model-status-text').textContent = 'Model: Ready';

            console.log('Manual floor alignment complete');
        }

        // Export GLB
        async function exportGLB() {
            try {
                document.getElementById('model-status-text').textContent = 'Exporting...';
                const glbUrl = `${API_BASE || ''}/api/export/glb`;

                const response = await fetch(glbUrl);
                if (!response.ok) {
                    throw new Error(`Export failed with status ${response.status}`);
                }

                const blob = await response.blob();
                // Try to honor filename from Content-Disposition; fall back to a default
                const disposition = response.headers.get('Content-Disposition') || '';
                let filename = 'point_cloud.glb';
                const utfMatch = disposition.match(/filename\\*=UTF-8''([^;]+)/);
                const plainMatch = disposition.match(/filename=\"?([^\";]+)\"?/);
                if (utfMatch) {
                    filename = decodeURIComponent(utfMatch[1]);
                } else if (plainMatch) {
                    filename = plainMatch[1];
                }

                const downloadUrl = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                window.URL.revokeObjectURL(downloadUrl);

                document.getElementById('model-status-text').textContent = 'Model: Ready';
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export. Check console for details.');
                document.getElementById('model-status-text').textContent = 'Model: Ready';
            }
        }

        // Reset view
        function resetView() {
            camera.position.set(0, CAMERA_HEIGHT, 5);  // Reset to eye level
            camera.lookAt(new THREE.Vector3(0, CAMERA_HEIGHT, 0));
            if (controls) controls.update(0);
        }

        function disableNavigationControls() {
            if (flyControls) flyControls.enabled = false;
            if (orbitControls) orbitControls.enabled = false;
            controls = null;
        }

        function isFPSMode() {
            return activeCameraMode === 'FPS';
        }

        function setCameraMode(mode) {
            if (!CAMERA_MODES.includes(mode)) return;

            activeCameraMode = mode;
            currentCameraModeIndex = CAMERA_MODES.indexOf(mode);

            if (mode === 'FPS') {
                disableNavigationControls();
                updateCameraModeButtonState();
                if (!pointerLocked) {
                    requestPointerLock();
                }
                console.log('FPS Mode activated');
                return;
            }

            if (pointerLocked || pointerLockControls) {
                exitPointerLock();
            }

            disableNavigationControls();

            if (mode === 'FLY' && flyControls) {
                flyControls.enabled = true;
                controls = flyControls;
            } else if (mode === 'ORBIT' && orbitControls) {
                orbitControls.enabled = true;
                controls = orbitControls;
            }

            updateCameraModeButtonState();
            console.log(`${mode} Mode activated`);
        }

        function cycleCameraMode() {
            currentCameraModeIndex = (currentCameraModeIndex + 1) % CAMERA_MODES.length;
            setCameraMode(CAMERA_MODES[currentCameraModeIndex]);
        }

        function updateCameraModeButtonState() {
            const btn = document.getElementById('camera-mode-btn');
            const text = document.getElementById('camera-mode-text');
            if (!btn || !text) return;

            const mode = activeCameraMode;
            const style = CAMERA_MODE_STYLES[mode] || {};
            text.textContent = `${CAMERA_MODE_LABELS[mode] || mode} Mode`;

            if (style.background) btn.style.background = style.background;
            if (style.border) btn.style.borderColor = style.border;
        }

        function setupModalCloseHandler() {
            // Close modal when clicking outside
            window.addEventListener('click', (e) => {
                const modelModal = document.getElementById('model-modal');
                const configModal = document.getElementById('config-modal');
                if (modelModal && e.target === modelModal) {
                    closeModelSelector();
                }
                if (configModal && e.target === configModal) {
                    closeConfigModal();
                }
            });
        }

        function setupManualFloorSelection() {
            // Add click listener for manual floor selection
            if (renderer && renderer.domElement) {
                renderer.domElement.addEventListener('click', onMouseClick, false);
                console.log('Manual floor selection click handler registered');
            }
        }

        // ============================================================================
        // VIDEO PLAYBACK AND CAMERA PATH
        // ============================================================================

        class VideoPlayer {
            constructor() {
                this.currentFrame = 0;
                this.videoInfo = null;
                this.isPlaying = false;
                this.isLooping = true;
                this.pointCloudMesh = null;
                this.playbackTimer = null;
                this.frameBuffer = new Map();
                this.bufferSize = 5;
                this.cameraPathLine = null;
                this.cameraFrustums = [];
                this.showCameraPath = false;
            }

            async loadVideo() {
                try {
                    const res = await fetch('/api/video/info');
                    if (!res.ok) {
                        console.log('No video sequence available');
                        return false;
                    }

                    this.videoInfo = await res.json();
                    console.log('Video loaded:', this.videoInfo);

                    // Update UI
                    document.getElementById('video-controls').style.display = 'flex';
                    document.getElementById('frame-slider').max = this.videoInfo.num_frames - 1;
                    document.getElementById('fps-display').textContent = `${this.videoInfo.fps} FPS`;
                    this.updateFrameCounter();

                    // Load first frame
                    await this.loadFrame(0);
                    return true;
                } catch (err) {
                    console.error('Failed to load video:', err);
                    return false;
                }
            }

            async loadFrame(frameIndex) {
                if (!this.videoInfo) return;

                // Check buffer first
                if (!this.frameBuffer.has(frameIndex)) {
                    await this.preloadFrames(frameIndex);
                }

                const frame = this.frameBuffer.get(frameIndex);
                if (!frame) {
                    console.error('Frame not in buffer:', frameIndex);
                    return;
                }

                this.currentFrame = frameIndex;
                this.updatePointCloud(frame.vertices, frame.colors);
                this.updateFrameCounter();

                // Update slider
                const slider = document.getElementById('frame-slider');
                if (slider) slider.value = frameIndex;

                // Preload next batch if needed
                if ((frameIndex + 1) % this.bufferSize === 0) {
                    this.preloadFrames(frameIndex + 1);
                }
            }

            async preloadFrames(startIndex) {
                const endIndex = Math.min(
                    startIndex + this.bufferSize,
                    this.videoInfo.num_frames
                );

                try {
                    const res = await fetch(`/api/video/frames?start=${startIndex}&end=${endIndex}`);
                    const data = await res.json();

                    data.frames.forEach(frame => {
                        this.frameBuffer.set(frame.frame_index, frame);
                    });
                } catch (err) {
                    console.error('Failed to preload frames:', err);
                }
            }

            updatePointCloud(vertices, colors) {
                if (!scene) return;

                // Remove old point cloud
                if (this.pointCloudMesh) {
                    scene.remove(this.pointCloudMesh);
                    if (this.pointCloudMesh.geometry) this.pointCloudMesh.geometry.dispose();
                    if (this.pointCloudMesh.material) this.pointCloudMesh.material.dispose();
                }

                // Create new point cloud
                const positions = new Float32Array(vertices.flat());
                const colorsArray = new Float32Array(colors.flat().map(c => c / 255));

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.015,
                    vertexColors: true,
                    sizeAttenuation: true
                });

                this.pointCloudMesh = new THREE.Points(geometry, material);
                scene.add(this.pointCloudMesh);

                // Store in global state
                if (typeof activePointCloud !== 'undefined') {
                    activePointCloud = this.pointCloudMesh;
                }
            }

            updateFrameCounter() {
                const counter = document.getElementById('frame-counter');
                if (counter && this.videoInfo) {
                    counter.textContent = `${this.currentFrame + 1} / ${this.videoInfo.num_frames}`;
                }
            }

            async play() {
                if (!this.videoInfo || this.isPlaying) return;

                this.isPlaying = true;
                const frameDelay = 1000 / this.videoInfo.fps;

                const playFrame = async () => {
                    if (!this.isPlaying) return;

                    await this.loadFrame(this.currentFrame);

                    // Advance to next frame
                    this.currentFrame++;
                    if (this.currentFrame >= this.videoInfo.num_frames) {
                        if (this.isLooping) {
                            this.currentFrame = 0;
                        } else {
                            this.pause();
                            return;
                        }
                    }

                    this.playbackTimer = setTimeout(playFrame, frameDelay);
                };

                playFrame();
                console.log('Video playback started');
            }

            pause() {
                this.isPlaying = false;
                if (this.playbackTimer) {
                    clearTimeout(this.playbackTimer);
                    this.playbackTimer = null;
                }
                console.log('Video playback paused');
            }

            stop() {
                this.pause();
                this.currentFrame = 0;
                if (this.videoInfo) {
                    this.loadFrame(0);
                }
                console.log('Video playback stopped');
            }

            seekToFrame(frameIndex) {
                const wasPlaying = this.isPlaying;
                this.pause();
                this.loadFrame(frameIndex);
                if (wasPlaying) {
                    this.play();
                }
            }

            toggleLoop() {
                this.isLooping = !this.isLooping;
                const btn = document.getElementById('video-loop-btn');
                if (btn) {
                    btn.style.background = this.isLooping
                        ? 'rgba(16, 185, 129, 0.4)'
                        : 'rgba(16, 185, 129, 0.2)';
                }
                console.log('Loop:', this.isLooping ? 'ON' : 'OFF');
            }

            async toggleCameraPath() {
                this.showCameraPath = !this.showCameraPath;

                const btn = document.getElementById('video-camera-path-btn');
                if (btn) {
                    btn.style.background = this.showCameraPath
                        ? 'rgba(16, 185, 129, 0.4)'
                        : 'rgba(16, 185, 129, 0.2)';
                }

                if (this.showCameraPath) {
                    await this.loadAndDisplayCameraPath();
                } else {
                    this.clearCameraPath();
                }
            }

            async loadAndDisplayCameraPath() {
                try {
                    const res = await fetch('/api/video/camera_path');
                    const data = await res.json();

                    this.clearCameraPath();

                    // Draw camera path line
                    const pathPoints = data.positions.map(pos => new THREE.Vector3(...pos));
                    const pathGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
                    const pathMaterial = new THREE.LineBasicMaterial({
                        color: 0xff0000,
                        linewidth: 2,
                        opacity: 0.8,
                        transparent: true
                    });
                    this.cameraPathLine = new THREE.Line(pathGeometry, pathMaterial);
                    scene.add(this.cameraPathLine);

                    // Add camera frustums
                    data.poses.forEach((pose, index) => {
                        const frustum = this.createCameraFrustum(pose, index);
                        this.cameraFrustums.push(frustum);
                        scene.add(frustum);
                    });

                    console.log('Camera path displayed with', data.num_frames, 'poses');
                } catch (err) {
                    console.error('Failed to load camera path:', err);
                }
            }

            createCameraFrustum(poseMatrix, index) {
                // Create a small pyramid to represent camera
                const geometry = new THREE.ConeGeometry(0.05, 0.1, 4);
                geometry.rotateX(Math.PI / 2); // Point along Z axis

                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    wireframe: true,
                    opacity: 0.6,
                    transparent: true
                });
                const frustum = new THREE.Mesh(geometry, material);

                // Apply camera pose
                const matrix = new THREE.Matrix4();
                const flatMatrix = poseMatrix.flat ? poseMatrix.flat() : [].concat(...poseMatrix);
                matrix.fromArray(flatMatrix);
                frustum.applyMatrix4(matrix);

                frustum.userData.frameIndex = index;
                return frustum;
            }

            clearCameraPath() {
                if (this.cameraPathLine) {
                    scene.remove(this.cameraPathLine);
                    if (this.cameraPathLine.geometry) this.cameraPathLine.geometry.dispose();
                    if (this.cameraPathLine.material) this.cameraPathLine.material.dispose();
                    this.cameraPathLine = null;
                }

                this.cameraFrustums.forEach(frustum => {
                    scene.remove(frustum);
                    if (frustum.geometry) frustum.geometry.dispose();
                    if (frustum.material) frustum.material.dispose();
                });
                this.cameraFrustums = [];
            }

            reset() {
                this.stop();
                this.clearCameraPath();
                this.frameBuffer.clear();
                this.videoInfo = null;
                this.showCameraPath = false;
                document.getElementById('video-controls').style.display = 'none';
            }
        }

        // Global video player instance
        const videoPlayer = new VideoPlayer();

        // ============================================================================

        // Initialize on load
        window.addEventListener('DOMContentLoaded', async () => {
            console.log('Initializing Depth Anything 3 UI...');

            updateApiDisplay();
            const apiPill = document.getElementById('api-base-display');
            if (apiPill) {
                apiPill.addEventListener('click', () => {
                    const next = prompt('Enter API base (e.g., http://127.0.0.1:5000)', API_BASE);
                    if (next) setApiBase(next);
                });
            }

            const apiReady = await verifyApiBase();
            if (!apiReady) {
                console.error('API base not reachable; UI init halted.');
                return;
            }

            // Initialize Three.js scene
            initThreeJS();
            console.log('Three.js scene initialized');

            // Setup event handlers
            setupDragAndDrop();
            setupModalCloseHandler();
            setupKeyboardControls();
            setupPointerLockControls();
            setupManualFloorSelection();
            syncConfigModalFromState();
            console.log('Event handlers setup complete');

            // Update model status
            updateModelStatus();
            hydrateModelStatus();
            console.log('UI initialization complete');
        });
    </script>
</body>
</html>
