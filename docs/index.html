
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth Anything 3 - Point Cloud Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/FlyControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/math/ConvexHull.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/ConvexGeometry.js"></script>
    <script>
        // Prefix all /api/... requests with an overridable base URL so the UI can talk to a remote API.
        const urlParams = new URLSearchParams(window.location.search);
        const storedApi = (() => {
            try { return localStorage.getItem('da3_api_base'); } catch (_) { return null; }
        })();
        const normalizeBase = (base) => {
            if (!base) return '';
            return base.endsWith('/') ? base.slice(0, -1) : base;
        };
        const deriveDefaultBase = () => {
            const host = (window.location && window.location.hostname) ? window.location.hostname : 'localhost';
            // Default to http with API on port 5000
            return `http://${host || 'localhost'}:5000`;
        };
        let API_BASE = normalizeBase(
            urlParams.get('api') ||
            (typeof window !== 'undefined' ? window.API_BASE_URL : '') ||
            storedApi ||
            deriveDefaultBase()
        );
        try { localStorage.setItem('da3_api_base', API_BASE); } catch (_) {}
        const originalFetch = window.fetch.bind(window);
        window.fetch = (input, init) => {
            if (typeof input === 'string' && input.startsWith('/api/')) {
                return originalFetch(API_BASE + input, init);
            }
            return originalFetch(input, init);
        };
        window.setApiBase = (base) => {
            API_BASE = normalizeBase(base);
            try { localStorage.setItem('da3_api_base', API_BASE); } catch (_) {}
            updateApiDisplay();
            console.log('API base set to', API_BASE);
        };

        async function verifyApiBase() {
            const candidates = [];
            if (API_BASE) candidates.push(API_BASE);

            const host = (window.location && window.location.hostname) ? window.location.hostname : 'localhost';
            const fallback = normalizeBase(`http://${host || 'localhost'}:5000`);
            if (!candidates.includes(fallback)) candidates.push(fallback);

            for (const base of candidates) {
                try {
                    const res = await originalFetch(base + '/api/v1/health', { method: 'GET' });
                    if (res.ok) {
                        setApiBase(base);
                        return true;
                    }
                } catch (err) {
                    console.warn('API probe failed for', base, err);
                }
            }

            const manual = prompt('API server not reachable. Enter API base (e.g., http://127.0.0.1:5000)', candidates[0] || fallback);
            if (manual) {
                setApiBase(manual);
                return verifyApiBase();
            }

            alert('API is not reachable. Please restart with a valid API base to use the UI.');
            return false;
        }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        /* Full-screen Three.js canvas */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Sign flip helper panel */
        #sign-flip-panel {
            position: fixed;
            top: 70px;
            left: 10px;
            z-index: 110;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 10px 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
            display: flex;
            flex-direction: column;
            gap: 8px;
            color: #fff;
            font-size: 13px;
            backdrop-filter: blur(8px);
        }

        #sign-flip-panel h4 {
            margin: 0;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: #cbd5ff;
        }

        #sign-flip-panel .flip-buttons {
            display: flex;
            gap: 6px;
        }

        #sign-flip-panel .flip-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        #sign-flip-panel button {
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            min-width: 48px;
            transition: all 0.15s ease;
        }

        #sign-flip-panel button.active {
            background: rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.8);
            color: #e7fff7;
        }

        #sign-flip-panel button:hover {
            background: rgba(255, 255, 255, 0.16);
            border-color: rgba(255, 255, 255, 0.4);
        }

        /* Top button bar */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            z-index: 100;
        }

        .top-bar button {
            padding: 10px 20px;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.5);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .top-bar button:hover {
            background: rgba(59, 130, 246, 0.4);
            border-color: rgba(59, 130, 246, 0.8);
        }

        .top-bar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .top-bar .title {
            font-size: 18px;
            font-weight: 600;
            margin-right: auto;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        /* Bottom button bar */
        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            gap: 15px;
            z-index: 100;
        }

        .bottom-bar button {
            padding: 12px 24px;
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.5);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bottom-bar button:hover:not(:disabled) {
            background: rgba(16, 185, 129, 0.4);
            border-color: rgba(16, 185, 129, 0.8);
            transform: translateY(-2px);
        }

        .bottom-bar button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Responsive icon-only top/bottom bars */
        @media (max-width: 768px) {
            .top-bar {
                height: 56px;
                gap: 10px;
                padding: 0 12px;
            }
            .bottom-bar {
                height: 64px;
                gap: 10px;
                padding: 0 12px;
            }
            .top-bar button,
            .bottom-bar button {
                padding: 10px 12px;
                min-width: 44px;
                justify-content: center;
            }
            .top-bar .title .title-text,
            .top-bar button .btn-label,
            .bottom-bar button .btn-label {
                display: none;
            }
        }

        /* Drag and drop overlay */
        .drag-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(59, 130, 246, 0.1);
            backdrop-filter: blur(20px);
            border: 3px dashed rgba(59, 130, 246, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .drag-overlay.active {
            display: flex;
        }

        .drag-content {
            text-align: center;
            padding: 40px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            border: 2px solid rgba(59, 130, 246, 0.5);
        }

        .drag-content i {
            font-size: 80px;
            color: #3b82f6;
            margin-bottom: 20px;
        }

        .drag-content h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .drag-content p {
            font-size: 16px;
            color: #aaa;
        }

        /* Model selection modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1e293b, #0f172a);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 20px;
            padding: 30px;
            max-width: 900px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header h2 {
            font-size: 24px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .modal-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            padding: 5px 10px;
        }

        .model-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .model-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .model-card:hover {
            border-color: rgba(59, 130, 246, 0.5);
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
        }

        .model-card.current {
            border-color: rgba(16, 185, 129, 0.8);
            background: rgba(16, 185, 129, 0.1);
        }

        .model-card.current::before {
            content: "✓ Current";
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(16, 185, 129, 0.8);
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: 600;
        }

        .model-card h3 {
            font-size: 16px;
            margin-bottom: 8px;
            color: #3b82f6;
        }

        .model-card .description {
            font-size: 13px;
            color: #aaa;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .model-card .meta {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .model-card .meta-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .model-card .download-btn {
            width: 100%;
            padding: 8px;
            background: rgba(59, 130, 246, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.5);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 13px;
            margin-top: 10px;
        }

        .model-card .download-btn:hover {
            background: rgba(59, 130, 246, 0.5);
        }

        .model-card.downloaded .download-btn {
            background: rgba(16, 185, 129, 0.2);
            border-color: rgba(16, 185, 129, 0.5);
        }

        /* Config modal */
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 14px;
        }

        .config-section {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 12px 14px;
        }

        .config-section h4 {
            font-size: 14px;
            margin-bottom: 6px;
            color: #93c5fd;
            letter-spacing: 0.3px;
        }

        .config-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin: 6px 0;
            font-size: 13px;
        }

        .config-row label {
            flex: 1 1 55%;
            color: #cbd5e1;
        }

        .config-row input,
        .config-row select {
            flex: 1 1 45%;
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            padding: 7px 8px;
            color: #fff;
            font-size: 13px;
        }

        .config-row input[type="checkbox"] {
            flex: 0 0 auto;
            width: 18px;
            height: 18px;
            accent-color: #3b82f6;
        }

        .config-subtext {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 4px;
            line-height: 1.4;
        }

        .config-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 16px;
        }

        .config-footer button {
            padding: 10px 16px;
            background: rgba(59, 130, 246, 0.25);
            border: 1px solid rgba(59, 130, 246, 0.6);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
        }

        .config-footer button.secondary {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.12);
        }

        /* Camera modal */
        .camera-modal-content {
            max-width: 900px;
        }

        .camera-layout {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
        }

        .camera-preview {
            flex: 1 1 360px;
            min-height: 260px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .camera-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #000;
        }

        .camera-controls {
            flex: 1 1 260px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .camera-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .camera-actions button,
        .camera-close-btn {
            flex: 1 1 180px;
            padding: 12px 14px;
            background: rgba(59, 130, 246, 0.25);
            border: 1px solid rgba(59, 130, 246, 0.6);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            font-size: 14px;
        }

        .camera-actions button.recording {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.6);
        }

        .camera-actions button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .camera-close-btn {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.12);
            width: 100%;
        }

        .camera-status {
            font-size: 13px;
            color: #cbd5e1;
            line-height: 1.5;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
        }

        .camera-status.info {
            color: #cbd5e1;
        }

        .camera-status.ready {
            color: #a5f3fc;
        }

        .camera-status.error {
            color: #fca5a5;
        }

        /* Status indicator */
        .status-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px 20px;
            z-index: 100;
            min-width: 250px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 13px;
        }

        .status-icon {
            font-size: 16px;
        }

        .status-loading { color: #f59e0b; }
        .status-ready { color: #10b981; }
        .status-error { color: #ef4444; }

        /* Progress bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s;
        }

        /* Hidden file input */
        #file-input {
            display: none;
        }

        .api-pill {
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            font-size: 12px;
            color: #cbd5e1;
            white-space: nowrap;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .api-pill {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Full-screen Three.js canvas -->
    <div id="canvas-container"></div>

    <!-- Top button bar -->
    <div class="top-bar">
        <div class="title">
            <i class="fas fa-cube"></i> <span class="title-text">Depth Anything 3</span>
        </div>
        <div class="api-pill" id="api-base-display"></div>
        <button onclick="showConfigModal()" id="config-btn">
            <i class="fas fa-sliders-h"></i> <span class="btn-label">Configure</span>
        </button>
        <button onclick="showModelSelector()">
            <i class="fas fa-brain"></i>
            <span id="current-model-name" class="btn-label">Select Model</span>
        </button>
        <button onclick="document.getElementById('file-input').click()">
            <i class="fas fa-folder-open"></i> <span class="btn-label">Browse Files</span>
        </button>
        <button onclick="openCameraModal()" id="camera-input-btn">
            <i class="fas fa-video"></i> <span class="btn-label">Camera</span>
        </button>
        <button onclick="loadModel()" id="load-model-btn">
            <i class="fas fa-download"></i> <span class="btn-label">Load Model</span>
        </button>
    </div>

    <!-- Bottom button bar -->
    <div class="bottom-bar">
        <!-- Video Controls (hidden by default) -->
        <div id="video-controls" style="display: none; flex: 1; max-width: 820px; margin-right: 20px;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                <button onclick="videoPlayer.play()" id="video-play-btn" style="flex: 0; min-width: 40px; padding: 8px;">
                    <i class="fas fa-play"></i>
                </button>
                <button onclick="videoPlayer.pause()" id="video-pause-btn" style="flex: 0; min-width: 40px; padding: 8px;">
                    <i class="fas fa-pause"></i>
                </button>
                <button onclick="videoPlayer.stop()" id="video-stop-btn" style="flex: 0; min-width: 40px; padding: 8px;">
                    <i class="fas fa-stop"></i>
                </button>
                <button onclick="videoPlayer.toggleLoop()" id="video-loop-btn" style="flex: 0; min-width: 40px; padding: 8px;" title="Loop">
                    <i class="fas fa-repeat"></i>
                </button>
                <button onclick="videoPlayer.toggleCameraPath()" id="video-camera-path-btn" style="flex: 0; min-width: 40px; padding: 8px;" title="Show Camera Path">
                    <i class="fas fa-route"></i>
                </button>
                <button onclick="videoPlayer.toggleAttachToPath()" id="video-follow-cam-btn" style="flex: 0; min-width: 40px; padding: 8px;" title="Attach viewer to camera spline">
                    <i class="fas fa-magnet"></i>
                </button>
                <button onclick="videoPlayer.toggleFrameOnly()" id="video-frame-only-btn" style="flex: 0; min-width: 40px; padding: 8px;" title="Show only the current frame's point cloud">
                    <i class="fas fa-filter"></i>
                </button>
                <button onclick="videoPlayer.playWalkthrough()" id="video-walkthrough-btn" style="flex: 0; min-width: 40px; padding: 8px;" title="Playback along camera path">
                    <i class="fas fa-person-walking"></i>
                </button>
                <span id="frame-counter" style="color: rgba(255,255,255,0.7); font-size: 12px; white-space: nowrap;">0 / 0</span>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="frame-slider" min="0" max="0" value="0"
                       style="flex: 1; accent-color: #3b82f6;"
                       oninput="videoPlayer.seekToFrame(parseInt(this.value))">
                <span id="fps-display" style="color: rgba(255,255,255,0.5); font-size: 11px; white-space: nowrap;">15 FPS</span>
            </div>
        </div>

        <button onclick="exportGLB()" id="export-btn" disabled>
            <i class="fas fa-file-export"></i> <span class="btn-label">Export GLB</span>
        </button>
        <button onclick="alignFloor()" id="floor-btn" disabled>
            <i class="fas fa-align-center"></i> <span class="btn-label">Auto Floor</span>
        </button>
        <button onclick="toggleManualFloorSelection()" id="manual-floor-btn" disabled>
            <i class="fas fa-mouse-pointer"></i> <span id="manual-floor-text" class="btn-label">Select Floor</span>
        </button>
        <button onclick="cycleCameraMode()" id="camera-mode-btn" disabled>
            <i class="fas fa-running"></i> <span id="camera-mode-text" class="btn-label">Fly Mode</span>
        </button>
        <button onclick="resetView()" id="reset-btn" disabled>
            <i class="fas fa-undo"></i> <span class="btn-label">Reset View</span>
        </button>
    </div>

    <!-- Pointer lock activation circle -->
    <div id="pointer-lock-indicator" style="
        position: fixed;
        pointer-events: none;
        display: none;
        z-index: 10000;
    ">
        <svg width="80" height="80" style="transform: translate(-40px, -40px);">
            <circle cx="40" cy="40" r="35" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="3"/>
            <circle id="progress-circle" cx="40" cy="40" r="35" fill="none" stroke="rgba(59, 130, 246, 0.8)"
                    stroke-width="3" stroke-dasharray="220" stroke-dashoffset="220"
                    style="transform: rotate(-90deg); transform-origin: 50% 50%; transition: stroke-dashoffset 0.1s linear;"/>
            <text x="40" y="45" text-anchor="middle" fill="white" font-size="12" font-family="Arial">Hold</text>
        </svg>
    </div>

    <!-- Pointer lock exit indicator -->
    <div id="pointer-lock-active" style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        display: none;
        z-index: 10000;
    ">
        <div style="
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
        "></div>
    </div>

    <!-- Drag and drop overlay -->
    <div class="drag-overlay" id="drag-overlay">
        <div class="drag-content">
            <i class="fas fa-cloud-upload-alt"></i>
            <h2>Drop your file here</h2>
            <p>Images (JPG, PNG) or Videos (MP4, AVI, MOV)</p>
        </div>
    </div>

    <!-- Model selection modal -->
    <div class="modal" id="model-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-brain"></i> Select Model</h2>
                <button class="modal-close" onclick="closeModelSelector()">×</button>
            </div>
            <div id="model-grid" class="model-grid">
                <!-- Models will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Config modal -->
    <div class="modal" id="config-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-sliders-h"></i> Viewer & Model Config</h2>
                <button class="modal-close" onclick="closeConfigModal()">×</button>
            </div>
            <div class="config-grid">
                <div class="config-section">
                    <h4>DA3 Inference</h4>
                    <div class="config-row">
                        <label for="process-res-input">Processing Resolution</label>
                        <input type="number" id="process-res-input" min="256" max="2048" step="16" value="504">
                    </div>
                    <div class="config-row">
                        <label for="process-res-method">Resize Method</label>
                        <select id="process-res-method">
                            <option value="upper_bound_resize">upper_bound_resize</option>
                            <option value="upper_bound_crop">upper_bound_crop</option>
                            <option value="lower_bound_resize">lower_bound_resize</option>
                            <option value="lower_bound_crop">lower_bound_crop</option>
                        </select>
                    </div>
                    <div class="config-row">
                        <label for="max-points-input">Max Points</label>
                        <input type="number" id="max-points-input" min="10000" max="2000000" step="10000" value="1000000">
                    </div>
                    <div class="config-row">
                        <label for="align-scale-checkbox">Align to Input Scale</label>
                        <input type="checkbox" id="align-scale-checkbox" checked>
                    </div>
                    <div class="config-row">
                        <label for="infer-gs-checkbox">Infer Gaussian Splat</label>
                        <input type="checkbox" id="infer-gs-checkbox">
                    </div>
                    <div class="config-row">
                        <label for="export-feat-layers">Export Feature Layers</label>
                        <input type="text" id="export-feat-layers" placeholder="e.g. 0,1,2">
                    </div>
                </div>

                <div class="config-section">
                    <h4>Depth Filtering</h4>
                    <div class="config-row">
                        <label for="confidence-filter-toggle">Filter by Confidence</label>
                        <input type="checkbox" id="confidence-filter-toggle">
                    </div>
                    <div class="config-row">
                        <label for="confidence-percentile-input">Confidence Percentile</label>
                        <input type="number" id="confidence-percentile-input" min="0" max="100" step="1" value="40">
                    </div>
                    <div class="config-row">
                        <label for="include-confidence-toggle">Return Confidence</label>
                        <input type="checkbox" id="include-confidence-toggle">
                    </div>
                    <div class="config-row">
                        <label for="show-cameras-toggle">Show Cameras in Exports</label>
                        <input type="checkbox" id="show-cameras-toggle" checked>
                    </div>
                    <div class="config-row">
                        <label for="feat-vis-fps-input">Feature Vis FPS</label>
                        <input type="number" id="feat-vis-fps-input" min="1" max="60" step="1" value="15">
                    </div>
                    <div class="config-subtext">These map directly to DA3 inference options so you can drive the full library feature set.</div>
                </div>

                <div class="config-section">
                    <h4>Point Cloud Styling</h4>
                    <div class="config-row">
                        <label for="point-size-input">Point Size</label>
                        <input type="number" id="point-size-input" min="0.002" max="0.1" step="0.001" value="0.01">
                    </div>
                    <div class="config-row">
                        <label for="point-shape-select">Point Shape</label>
                        <select id="point-shape-select">
                            <option value="circle">Circle</option>
                            <option value="square">Square</option>
                        </select>
                    </div>
                    <div class="config-row">
                        <label for="mesh-toggle">Generate Mesh</label>
                        <input type="checkbox" id="mesh-toggle">
                    </div>
                    <div class="config-row">
                        <label for="mesh-sample-input">Mesh Sample Points</label>
                        <input type="number" id="mesh-sample-input" min="500" max="20000" step="500" value="3000">
                    </div>
                    <div class="config-row">
                        <label for="fill-sparse-toggle">Fill Sparse Distance Gaps</label>
                        <input type="checkbox" id="fill-sparse-toggle">
                    </div>
                    <div class="config-row">
                        <label for="fill-distance-input">Sparse Distance Threshold</label>
                        <input type="number" id="fill-distance-input" min="0.1" max="20" step="0.1" value="5">
                    </div>
                    <div class="config-row">
                        <label for="fill-neighbors-input">Neighbor Blend Count</label>
                        <input type="number" id="fill-neighbors-input" min="1" max="10" step="1" value="3">
                    </div>
                    <div class="config-row">
                        <label for="fill-newpoints-input">New Points (max)</label>
                        <input type="number" id="fill-newpoints-input" min="0" max="50000" step="500" value="5000">
                    </div>
                </div>
            </div>
            <div class="config-footer">
                <button class="secondary" onclick="resetConfigToDefaults()">Reset</button>
                <button onclick="applyConfigFromModal()">Apply</button>
            </div>
        </div>
    </div>

    <!-- Camera capture modal -->
    <div class="modal" id="camera-modal">
        <div class="modal-content camera-modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-video"></i> Camera Capture</h2>
                <button class="modal-close" onclick="closeCameraModal()">×</button>
            </div>
            <div class="camera-layout">
                <div class="camera-preview">
                    <video id="camera-preview" autoplay playsinline muted></video>
                    <canvas id="camera-canvas" style="display: none;"></canvas>
                </div>
                <div class="camera-controls">
                    <p class="camera-status info" id="camera-status">Allow camera access to capture a frame or quick video.</p>
                    <div class="camera-actions">
                        <button onclick="captureCameraFrame()" id="capture-frame-btn">
                            <i class="fas fa-camera"></i> Capture Frame
                        </button>
                        <button onclick="toggleCameraRecording()" id="record-video-btn">
                            <i class="fas fa-dot-circle"></i> Start Video
                        </button>
                    </div>
                    <button class="camera-close-btn" onclick="closeCameraModal()">
                        <i class="fas fa-times"></i> Close
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Status indicator -->
    <div class="status-indicator">
        <div class="status-item">
            <i class="fas fa-brain status-icon" id="model-status-icon"></i>
            <span id="model-status-text">Model: Not loaded</span>
        </div>
        <div class="progress-bar" id="progress-bar" style="display: none;">
            <div class="progress-fill" id="progress-fill" style="width: 0%;"></div>
        </div>
        <div class="status-item">
            <i class="fas fa-cube status-icon"></i>
            <span id="points-count">Points: 0</span>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="file-input" accept="image/*,video/*,.glb,.gltf,.json" onchange="handleFileSelect(this.files[0])">

    <script>
        // Three.js setup
        let scene, camera, renderer, controls, pointerLockControls, pointCloud;
        let flyControls = null;
        let orbitControls = null;
        let currentJobId = null;
        let currentModel = null;
        let manualFloorMode = false;
        let selectedPoints = [];
        let hoveredIndices = [];
        let selectedIndices = [];
        let hoveredLowestIndex = null;
        let selectedLowestIndex = null;
        let selectedAnchorPoint = null;
        let originalColorArray = null;  // immutable copy of colors (normalized)
        let baseColorArray = null;       // mutable working copy that includes selections
        let lastHoverTime = 0;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let originalPointCloudData = null;  // Store original point cloud data for color restoration
        let sourcePointCloudData = null;    // Raw data from backend/upload (unmodified)
        let activePointCloudData = null;    // Data after applying viewer config transforms
        let meshObject = null;

        const defaultConfig = {
            processRes: 504,
            processResMethod: 'upper_bound_resize',
            maxPoints: 1000000,
            alignToInputScale: true,
            inferGS: false,
            exportFeatLayers: '',
            applyConfidenceFilter: false,
            confidencePercentile: 40,
            includeConfidence: false,
            showCameras: true,
            featVisFps: 15,
            pointSize: 0.01,
            pointShape: 'circle',
            generateMesh: false,
            meshSamplePoints: 3000,
            fillSparse: false,
            sparseFillDistance: 5,
            sparseFillNeighbors: 3,
            sparseFillNewPoints: 5000
        };
        let viewerConfig = {...defaultConfig};

        // ============================================================================
        // CAMERA POSE COORDINATE SYSTEM DOCUMENTATION
        // ============================================================================
        //
        // **Backend Convention (Depth Anything 3):**
        // - The model predicts EXTRINSICS: 4x4 world-to-camera transformation matrices
        // - Backend INVERTS these to camera-to-world (c2w) before storing in frames
        // - Backend TRANSFORMS points from camera space to world space before storing
        // - Frame data contains c2w matrices (row-major) and world-space points
        //
        // **Frame Data (/api/video/frames):**
        // - "vertices": Point positions in WORLD SPACE (already transformed)
        // - "camera_pose": c2w matrix in row-major format (nested array)
        // - "camera_pose_col_major_flat": c2w matrix in column-major flat format (optimal)
        //
        // **Three.js Convention:**
        // - Matrix4.fromArray() expects COLUMN-MAJOR order: [col0, col1, col2, col3]
        // - Camera coordinate system: +X right, +Y up, -Z forward (into scene)
        // - Camera-to-world (c2w) matrix transforms from camera space to world space
        //
        // **Transformation Pipeline:**
        // 1. Model predicts extrinsics (w2c) → Backend inverts to c2w → Stores in frame.camera_pose
        // 2. Backend transforms points to world space → Stores in frame.vertices
        // 3. Backend transposes c2w for column-major → "camera_pose_col_major_flat"
        // 4. Frontend loads with Matrix4.fromArray() → Ready for Three.js
        //
        // **Point Cloud Display:**
        // - Points are ALREADY in world space, no transformation needed
        // - To visualize all frames together, we must transform to world space
        // - Transform: P_world = c2w * P_camera
        //
        // ============================================================================

        // Pose handling debug/normalization controls
        const POSE_DEBUG_CONFIG = {
            // Log the first raw pose returned by /api/video/... with no transforms applied
            logFirstRawPose: false,  // Changed to false - enable only for debugging
            rawPoseFrameIndex: 0,    // Frame to sample for the raw pose log
            // Toggle for ongoing pose diagnostics (normalized pose + forward vectors)
            enabled: false,
            drawForwardRay: false,
            forwardRayLength: 0.35
        };

        // Camera mode tracking
        const CAMERA_MODES = ['ORBIT', 'FLY', 'FPS'];
        const CAMERA_MODE_LABELS = {
            ORBIT: 'Orbit',
            FLY: 'Fly',
            FPS: 'FPS'
        };
        const CAMERA_MODE_STYLES = {
            ORBIT: { background: 'rgba(249, 115, 22, 0.25)', border: 'rgba(249, 115, 22, 0.6)' },
            FLY: { background: 'rgba(59, 130, 246, 0.25)', border: 'rgba(59, 130, 246, 0.6)' },
            FPS: { background: 'rgba(16, 185, 129, 0.25)', border: 'rgba(16, 185, 129, 0.6)' }
        };
        let currentCameraModeIndex = 1; // default to fly controls
        let activeCameraMode = CAMERA_MODES[currentCameraModeIndex];
        let pointerLocked = false;
        let holdStartTime = null;
        let holdTimeout = null;
        let holdAnimationFrame = null;
        let cameraYaw = 0;
        let cameraPitch = 0;
        const CAMERA_HEIGHT = 1.6;
        const WALK_SPEED = 3.5;
        const VERTICAL_SPEED = 2.0;
        const clock = new THREE.Clock();
        const tempEuler = new THREE.Euler(0, 0, 0, 'YXZ');  // used to zero roll in fly mode
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;

        function updateApiDisplay() {
            const pill = document.getElementById('api-base-display');
            if (pill) {
                pill.textContent = API_BASE || 'same-origin';
                pill.title = `Click to change API base (currently ${API_BASE || 'same-origin'})`;
            }
        }

        // Camera capture state
        let cameraStream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let shouldUploadRecording = true;
        let isRecording = false;

        function initThreeJS() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 10, 50);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.6, 5);  // Start at eye level (1.6m)

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // FlyControls (default free-fly camera)
            flyControls = new THREE.FlyControls(camera, renderer.domElement);
            flyControls.movementSpeed = 5;           // meters per second (scaled scene units)
            flyControls.rollSpeed = Math.PI / 8;     // softer roll feel
            flyControls.dragToLook = true;           // click-drag to pivot about camera position
            flyControls.autoForward = false;
            flyControls.enabled = false;

            // OrbitControls for anchor/turntable navigation
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.enablePan = true;
            orbitControls.screenSpacePanning = true;
            orbitControls.minDistance = 0.5;
            orbitControls.maxDistance = 200;
            orbitControls.enabled = false;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Axes
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // Set initial camera mode (fly)
            setCameraMode(activeCameraMode);

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Animation loop
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (isFPSMode() && pointerLocked && pointerLockControls) {
                // FPS mode movement (WASD/Arrows with pointer lock)
                const moveStep = WALK_SPEED * delta;
                const verticalStep = VERTICAL_SPEED * delta;

                if (moveForward) pointerLockControls.moveForward(moveStep);
                if (moveBackward) pointerLockControls.moveForward(-moveStep);
                if (moveLeft) pointerLockControls.moveRight(-moveStep);
                if (moveRight) pointerLockControls.moveRight(moveStep);

                const rig = pointerLockControls.getObject();
                if (moveUp) rig.position.y += verticalStep;
                if (moveDown) rig.position.y -= verticalStep;
            } else if (activeCameraMode === 'FLY') {
                if (flyControls && flyControls.enabled) {
                    flyControls.update(delta);
                    tempEuler.setFromQuaternion(camera.quaternion, 'YXZ');
                    tempEuler.z = 0;
                    camera.quaternion.setFromEuler(tempEuler);
                    camera.up.set(0, 1, 0);
                }
            } else if (activeCameraMode === 'ORBIT') {
                if (orbitControls && orbitControls.enabled) {
                    orbitControls.update();
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupDragAndDrop() {
            // Drag and drop
            document.addEventListener('dragover', (e) => {
                e.preventDefault();
                const overlay = document.getElementById('drag-overlay');
                if (overlay) overlay.classList.add('active');
            });

            document.addEventListener('dragleave', (e) => {
                if (e.target === document.body || e.target === document.documentElement) {
                    const overlay = document.getElementById('drag-overlay');
                    if (overlay) overlay.classList.remove('active');
                }
            });

            document.addEventListener('drop', (e) => {
                e.preventDefault();
                const overlay = document.getElementById('drag-overlay');
                if (overlay) overlay.classList.remove('active');

                if (e.dataTransfer.files.length > 0) {
                    handleFileSelect(e.dataTransfer.files[0]);
                }
            });
        }

        function setupKeyboardControls() {
            // Keyboard movement state tracking
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'w':
                    case 'W':
                    case 'ArrowUp':
                        moveForward = true;
                        break;
                    case 's':
                    case 'S':
                    case 'ArrowDown':
                        moveBackward = true;
                        break;
                    case 'a':
                    case 'A':
                    case 'ArrowLeft':
                        moveLeft = true;
                        break;
                    case 'd':
                    case 'D':
                    case 'ArrowRight':
                        moveRight = true;
                        break;
                    case 'q':
                    case 'Q':
                        moveUp = true;
                        break;
                    case 'e':
                    case 'E':
                        moveDown = true;
                        break;
                    case ' ':
                        if (pointerLockControls && pointerLocked) {
                            pointerLockControls.getObject().position.y = CAMERA_HEIGHT;
                        } else {
                            camera.position.y = CAMERA_HEIGHT;
                        }
                        e.preventDefault();
                        break;
                    case 'Escape':
                        if (isFPSMode()) {
                            e.preventDefault();
                            cycleCameraMode();
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.key) {
                    case 'w':
                    case 'W':
                    case 'ArrowUp':
                        moveForward = false;
                        break;
                    case 's':
                    case 'S':
                    case 'ArrowDown':
                        moveBackward = false;
                        break;
                    case 'a':
                    case 'A':
                    case 'ArrowLeft':
                        moveLeft = false;
                        break;
                    case 'd':
                    case 'D':
                    case 'ArrowRight':
                        moveRight = false;
                        break;
                    case 'q':
                    case 'Q':
                        moveUp = false;
                        break;
                    case 'e':
                    case 'E':
                        moveDown = false;
                        break;
                }
            });

            console.log('Keyboard controls enabled: WASD/Arrows=Move, Q/E=Up/Down, Space=Reset height');
        }

        function ensurePointerLockControls() {
            if (pointerLockControls) return;

            // Capture current camera transform before reparenting into controls
            const worldPos = new THREE.Vector3();
            const worldDir = new THREE.Vector3();
            camera.getWorldPosition(worldPos);
            camera.getWorldDirection(worldDir);

            pointerLockControls = new THREE.PointerLockControls(camera, renderer.domElement);
            pointerLockControls.pointerSpeed = 0.35;

            const rig = pointerLockControls.getObject();
            scene.add(rig);

            pointerLockControls.addEventListener('lock', handlePointerLockEnter);
            pointerLockControls.addEventListener('unlock', handlePointerLockExit);

            // Initialize rig orientation to match current view
            camera.position.set(0, 0, 0);
            camera.rotation.set(0, 0, 0); // clear any roll from fly mode

            cameraYaw = Math.atan2(worldDir.x, worldDir.z);
            cameraPitch = Math.asin(-worldDir.y);

            rig.position.copy(worldPos);
            rig.position.y = CAMERA_HEIGHT; // force eye height for FPS entry
            rig.rotation.y = cameraYaw;

            const pitchObject = rig.children[0];
            if (pitchObject) {
                pitchObject.rotation.x = cameraPitch;
            }
        }

        function syncPointerLockRig() {
            if (!pointerLockControls) return;

            const rig = pointerLockControls.getObject();
            const pitchObject = rig.children[0];
            const worldPos = new THREE.Vector3();
            const worldDir = new THREE.Vector3();

            camera.getWorldPosition(worldPos);
            camera.getWorldDirection(worldDir);

            cameraYaw = Math.atan2(worldDir.x, worldDir.z);
            cameraPitch = Math.asin(-worldDir.y);

            rig.position.copy(worldPos);
            rig.position.y = CAMERA_HEIGHT; // reset to FPS eye height to avoid drift
            rig.rotation.y = cameraYaw;

            if (pitchObject) {
                pitchObject.rotation.x = cameraPitch;
                pitchObject.rotation.z = 0; // remove roll from fly controls
            }

            // Clear any residual roll on the camera itself
            camera.rotation.set(0, 0, 0);
        }

        function handlePointerLockEnter() {
            pointerLocked = true;
            document.getElementById('pointer-lock-active').style.display = 'block';

            if (controls) controls.enabled = false;
            document.getElementById('model-status-text').textContent = 'First-Person Mode (ESC to exit)';
            console.log('Pointer lock activated - WASD/Arrows to move, mouse to look, ESC to exit');
        }

        function restoreCameraAfterPointerLock() {
            if (!pointerLockControls) return;

            const rig = pointerLockControls.getObject();
            const pitchObject = rig.children[0];

            const worldPos = new THREE.Vector3();
            const worldQuat = new THREE.Quaternion();
            camera.getWorldPosition(worldPos);
            camera.getWorldQuaternion(worldQuat);

            if (pitchObject && pitchObject.children.includes(camera)) {
                pitchObject.remove(camera);
            }

            scene.add(camera);
            camera.position.copy(worldPos);
            camera.quaternion.copy(worldQuat);

            scene.remove(rig);
            pointerLockControls.removeEventListener('lock', handlePointerLockEnter);
            pointerLockControls.removeEventListener('unlock', handlePointerLockExit);
            pointerLockControls.dispose();
            pointerLockControls = null;

            if (controls && !isFPSMode()) controls.enabled = true;
        }

        function handlePointerLockExit() {
            if (!pointerLocked && !pointerLockControls) return;

            pointerLocked = false;
            document.getElementById('pointer-lock-active').style.display = 'none';
            restoreCameraAfterPointerLock();

            if (isFPSMode()) {
                cycleCameraMode();
            }

            document.getElementById('model-status-text').textContent = 'Model: Ready';
            console.log('Pointer lock deactivated');
        }

        function exitPointerLock() {
            if (document.pointerLockElement) {
                document.exitPointerLock();
            } else if (pointerLocked || pointerLockControls) {
                handlePointerLockExit();
            }
        }

        function requestPointerLock() {
            if (!isFPSMode()) return;

            ensurePointerLockControls();
            syncPointerLockRig();

            if (pointerLockControls) {
                // Reset local camera rotation to align with yaw/pitch-only FPS rig
                camera.rotation.set(0, 0, 0);
                pointerLockControls.lock();
            }
        }

        function setupPointerLockControls() {
            const indicator = document.getElementById('pointer-lock-indicator');
            const progressCircle = document.getElementById('progress-circle');
            const circumference = 220; // Match stroke-dasharray

            // Start hold on mousedown (not in floor selection mode)
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 0 && !manualFloorMode && !pointerLocked && isFPSMode()) {
                    holdStartTime = Date.now();

                    // Position indicator at cursor
                    indicator.style.left = e.clientX + 'px';
                    indicator.style.top = e.clientY + 'px';
                    indicator.style.display = 'block';

                    // Animate progress circle
                    const animateProgress = () => {
                        const elapsed = Date.now() - holdStartTime;
                        const progress = Math.min(elapsed / 3000, 1); // 3 seconds
                        const offset = circumference - (progress * circumference);
                        progressCircle.style.strokeDashoffset = offset;

                        if (progress < 1) {
                            holdAnimationFrame = requestAnimationFrame(animateProgress);
                        }
                    };
                    animateProgress();

                    // Request pointer lock after 3 seconds
                    holdTimeout = setTimeout(() => {
                        indicator.style.display = 'none';
                        if (isFPSMode()) {
                            requestPointerLock();
                        }
                    }, 3000);
                }
            });

            // Cancel hold on mouseup or mouseleave
            const cancelHold = () => {
                if (holdTimeout) {
                    clearTimeout(holdTimeout);
                    holdTimeout = null;
                }
                if (holdAnimationFrame) {
                    cancelAnimationFrame(holdAnimationFrame);
                    holdAnimationFrame = null;
                }
                indicator.style.display = 'none';
                progressCircle.style.strokeDashoffset = circumference;
            };

            renderer.domElement.addEventListener('mouseup', cancelHold);
            renderer.domElement.addEventListener('mouseleave', cancelHold);

            console.log('Pointer lock controls ready: Hold mouse button for 3 seconds to activate');
        }

        function syncConfigModalFromState() {
            const setVal = (id, value) => {
                const el = document.getElementById(id);
                if (el) {
                    if (el.type === 'checkbox') {
                        el.checked = Boolean(value);
                    } else {
                        el.value = value;
                    }
                }
            };

            setVal('process-res-input', viewerConfig.processRes);
            setVal('process-res-method', viewerConfig.processResMethod);
            setVal('max-points-input', viewerConfig.maxPoints);
            setVal('align-scale-checkbox', viewerConfig.alignToInputScale);
            setVal('infer-gs-checkbox', viewerConfig.inferGS);
            setVal('export-feat-layers', viewerConfig.exportFeatLayers);
            setVal('confidence-filter-toggle', viewerConfig.applyConfidenceFilter);
            setVal('confidence-percentile-input', viewerConfig.confidencePercentile);
            setVal('include-confidence-toggle', viewerConfig.includeConfidence);
            setVal('show-cameras-toggle', viewerConfig.showCameras);
            setVal('feat-vis-fps-input', viewerConfig.featVisFps);
            setVal('point-size-input', viewerConfig.pointSize);
            setVal('point-shape-select', viewerConfig.pointShape);
            setVal('mesh-toggle', viewerConfig.generateMesh);
            setVal('mesh-sample-input', viewerConfig.meshSamplePoints);
            setVal('fill-sparse-toggle', viewerConfig.fillSparse);
            setVal('fill-distance-input', viewerConfig.sparseFillDistance);
            setVal('fill-neighbors-input', viewerConfig.sparseFillNeighbors);
            setVal('fill-newpoints-input', viewerConfig.sparseFillNewPoints);
        }

        function showConfigModal() {
            syncConfigModalFromState();
            document.getElementById('config-modal').classList.add('active');
        }

        function closeConfigModal() {
            document.getElementById('config-modal').classList.remove('active');
        }

        function applyConfigFromModal(closeAfter = true) {
            const numVal = (id, fallback) => {
                const el = document.getElementById(id);
                const parsed = parseFloat(el?.value);
                return Number.isNaN(parsed) ? fallback : parsed;
            };
            const intVal = (id, fallback) => {
                const el = document.getElementById(id);
                const parsed = parseInt(el?.value);
                return Number.isNaN(parsed) ? fallback : parsed;
            };
            const checked = (id, fallback) => {
                const el = document.getElementById(id);
                return el ? el.checked : fallback;
            };
            const textVal = (id, fallback) => {
                const el = document.getElementById(id);
                return el ? el.value : fallback;
            };

            viewerConfig.processRes = intVal('process-res-input', viewerConfig.processRes);
            viewerConfig.processResMethod = textVal('process-res-method', viewerConfig.processResMethod);
            viewerConfig.maxPoints = intVal('max-points-input', viewerConfig.maxPoints);
            viewerConfig.alignToInputScale = checked('align-scale-checkbox', viewerConfig.alignToInputScale);
            viewerConfig.inferGS = checked('infer-gs-checkbox', viewerConfig.inferGS);
            viewerConfig.exportFeatLayers = textVal('export-feat-layers', viewerConfig.exportFeatLayers);
            viewerConfig.applyConfidenceFilter = checked('confidence-filter-toggle', viewerConfig.applyConfidenceFilter);
            viewerConfig.confidencePercentile = numVal('confidence-percentile-input', viewerConfig.confidencePercentile);
            viewerConfig.includeConfidence = checked('include-confidence-toggle', viewerConfig.includeConfidence);
            viewerConfig.showCameras = checked('show-cameras-toggle', viewerConfig.showCameras);
            viewerConfig.featVisFps = intVal('feat-vis-fps-input', viewerConfig.featVisFps);
            viewerConfig.pointSize = numVal('point-size-input', viewerConfig.pointSize);
            viewerConfig.pointShape = textVal('point-shape-select', viewerConfig.pointShape);
            viewerConfig.generateMesh = checked('mesh-toggle', viewerConfig.generateMesh);
            viewerConfig.meshSamplePoints = intVal('mesh-sample-input', viewerConfig.meshSamplePoints);
            viewerConfig.fillSparse = checked('fill-sparse-toggle', viewerConfig.fillSparse);
            viewerConfig.sparseFillDistance = numVal('fill-distance-input', viewerConfig.sparseFillDistance);
            viewerConfig.sparseFillNeighbors = intVal('fill-neighbors-input', viewerConfig.sparseFillNeighbors);
            viewerConfig.sparseFillNewPoints = intVal('fill-newpoints-input', viewerConfig.sparseFillNewPoints);

            applyPointMaterialSettings();
            rebuildPointCloudWithConfig();
            if (viewerConfig.generateMesh) {
                buildMeshFromActiveCloud();
            } else {
                removeMesh();
            }

            if (closeAfter) {
                closeConfigModal();
            }
        }

        function resetConfigToDefaults() {
            viewerConfig = {...defaultConfig};
            syncConfigModalFromState();
            applyPointMaterialSettings();
            rebuildPointCloudWithConfig();
            if (viewerConfig.generateMesh) {
                buildMeshFromActiveCloud();
            } else {
                removeMesh();
            }
        }

        // Model selection
        async function showModelSelector() {
            const modal = document.getElementById('model-modal');
            modal.classList.add('active');

            // Load models
            const response = await fetch('/api/models/list');
            const data = await response.json();

            const grid = document.getElementById('model-grid');
            grid.innerHTML = '';

            data.models.forEach(model => {
                const card = document.createElement('div');
                card.className = 'model-card' + (model.current ? ' current' : '') + (model.downloaded ? ' downloaded' : '');

                // Build button HTML
                let buttonHtml = '';
                if (!model.downloaded) {
                    buttonHtml = `<button class="download-btn" onclick="selectAndDownloadModel('${model.id}')">Download & Load</button>`;
                } else if (!model.current) {
                    buttonHtml = `<button class="download-btn" onclick="selectModel('${model.id}')">Load Model</button>`;
                }

                card.innerHTML = `
                    <h3>${model.name}</h3>
                    <div class="description">${model.description}</div>
                    <div class="meta">
                        <div class="meta-item">${model.size}</div>
                        <div class="meta-item">${model.speed}</div>
                        <div class="meta-item">${model.quality}</div>
                    </div>
                    <div style="font-size: 11px; color: #888; margin-top: 5px;">
                        ${model.recommended_for}
                    </div>
                    ${buttonHtml}
                `;
                grid.appendChild(card);
            });
        }

        function closeModelSelector() {
            document.getElementById('model-modal').classList.remove('active');
        }

        async function selectModel(modelId) {
            const response = await fetch('/api/models/select', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({model_id: modelId})
            });

            if (response.ok) {
                closeModelSelector();
                updateModelStatus();
            }
        }

        async function selectAndDownloadModel(modelId) {
            await selectModel(modelId);
            await loadModel();
        }

        // Model loading
        async function loadModel() {
            try {
                const response = await fetch('/api/load_model', {method: 'POST'});
                const data = await response.json();

                if (response.ok) {
                    document.getElementById('model-status-text').textContent = 'Model: Loading...';
                    document.getElementById('model-status-icon').className = 'fas fa-spinner fa-spin status-icon status-loading';
                    document.getElementById('progress-bar').style.display = 'block';
                    const loadBtn = document.getElementById('load-model-btn');
                    if (loadBtn) {
                        loadBtn.disabled = true;
                        loadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
                    }

                    // Poll for status
                    pollModelStatus();
                } else {
                    alert('Error: ' + (data.message || data.error || 'Failed to start model loading'));
                }
            } catch (error) {
                console.error('Model loading error:', error);
                alert('Failed to load model. Check console for details.');
            }
        }

        async function pollModelStatus() {
            const interval = setInterval(async () => {
                const response = await fetch('/api/model_status');
                const data = await response.json();

                document.getElementById('progress-fill').style.width = data.progress + '%';

                if (data.status === 'ready') {
                    clearInterval(interval);
                    applyModelStatus(data);
                }
            }, 2000);
        }

        function applyModelStatus(statusData, currentModelName = null) {
            const textEl = document.getElementById('model-status-text');
            const iconEl = document.getElementById('model-status-icon');
            const progressBar = document.getElementById('progress-bar');
            const loadBtn = document.getElementById('load-model-btn');

            const setButtonsEnabled = (enabled) => {
                ['export-btn', 'floor-btn', 'manual-floor-btn', 'camera-mode-btn', 'reset-btn'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.disabled = !enabled;
                });
            };

            if (statusData.status === 'ready') {
                textEl.textContent = 'Model: Ready';
                iconEl.className = 'fas fa-check-circle status-icon status-ready';
                progressBar.style.display = 'none';
                setButtonsEnabled(true);
                if (loadBtn) {
                    loadBtn.disabled = true;
                    loadBtn.innerHTML = '<i class="fas fa-check-circle"></i> Model Loaded';
                }
            } else if (statusData.status === 'loading') {
                textEl.textContent = 'Model: Loading...';
                iconEl.className = 'fas fa-spinner fa-spin status-icon status-loading';
                progressBar.style.display = 'block';
                setButtonsEnabled(false);
                if (loadBtn) {
                    loadBtn.disabled = true;
                    loadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
                }
            } else {
                textEl.textContent = 'Model: Not loaded';
                iconEl.className = 'fas fa-brain status-icon';
                progressBar.style.display = 'none';
                setButtonsEnabled(false);
                if (loadBtn) {
                    loadBtn.disabled = false;
                    loadBtn.innerHTML = '<i class="fas fa-download"></i> Load Model';
                }
            }

            if (currentModelName) {
                document.getElementById('current-model-name').textContent = currentModelName;
            }
        }

        async function updateModelStatus() {
            const response = await fetch('/api/models/list');
            const data = await response.json();
            const current = data.models.find(m => m.current);
            if (current) {
                document.getElementById('current-model-name').textContent = current.name;
            }
            return current;
        }

        async function hydrateModelStatus() {
            try {
                const [statusRes, modelsRes] = await Promise.all([
                    fetch('/api/model_status'),
                    fetch('/api/models/list')
                ]);
                const statusData = await statusRes.json();
                const modelsData = await modelsRes.json();
                const current = modelsData.models.find(m => m.current);
                applyModelStatus(statusData, current ? current.name : null);
            } catch (err) {
                console.error('Failed to hydrate model status', err);
            }
        }

        // Camera capture (upload frame or quick video)
        async function openCameraModal() {
            document.getElementById('camera-modal').classList.add('active');
            updateRecordButton(false);
            await ensureCameraStream();
        }

        async function ensureCameraStream() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                setCameraStatus('Camera access is not supported in this browser.', 'error');
                return null;
            }

            if (cameraStream) {
                setCameraStatus('Camera ready. Capture a frame or record a clip.', 'ready');
                return cameraStream;
            }

            setCameraStatus('Requesting camera access...');
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' },
                    audio: false
                });

                const preview = document.getElementById('camera-preview');
                if (preview) {
                    preview.srcObject = cameraStream;
                    await preview.play();
                }

                setCameraStatus('Camera ready. Capture a frame or record a clip.', 'ready');

                cameraStream.getVideoTracks().forEach(track => {
                    track.onended = () => {
                        const modal = document.getElementById('camera-modal');
                        if (modal && modal.classList.contains('active')) {
                            stopCameraStream();
                            setCameraStatus('Camera disconnected. Reopen to request access again.', 'error');
                        }
                    };
                });

                return cameraStream;
            } catch (err) {
                console.error('Camera access error', err);
                setCameraStatus('Unable to access the camera. Please check permissions and try again.', 'error');
                return null;
            }
        }

        function setCameraStatus(message, state = 'info') {
            const status = document.getElementById('camera-status');
            if (!status) return;
            status.textContent = message;
            status.classList.remove('ready', 'error', 'info');
            if (state) {
                status.classList.add(state);
            }
        }

        function stopCameraStream() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            const preview = document.getElementById('camera-preview');
            if (preview) {
                preview.pause();
                preview.srcObject = null;
            }
        }

        function closeCameraModal() {
            document.getElementById('camera-modal').classList.remove('active');
            stopCameraRecording(true);
            stopCameraStream();
            setCameraStatus('Allow camera access to capture a frame or quick video.', 'info');
        }

        async function captureCameraFrame() {
            if (isRecording) {
                setCameraStatus('Stop recording before capturing a frame.', 'error');
                return;
            }

            const stream = await ensureCameraStream();
            if (!stream) return;

            const video = document.getElementById('camera-preview');
            const canvas = document.getElementById('camera-canvas');
            const width = video.videoWidth || 1280;
            const height = video.videoHeight || 720;

            if (!width || !height) {
                setCameraStatus('Camera is warming up... try again in a second.', 'error');
                return;
            }

            canvas.width = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, width, height);

            canvas.toBlob((blob) => {
                if (!blob) {
                    setCameraStatus('Failed to capture frame. Try again.', 'error');
                    return;
                }
                const file = new File([blob], `camera-frame-${Date.now()}.png`, { type: 'image/png' });
                setCameraStatus('Uploading frame...', 'ready');
                handleFileSelect(file);
                closeCameraModal();
            }, 'image/png');
        }

        function updateRecordButton(recording) {
            const recordBtn = document.getElementById('record-video-btn');
            const captureBtn = document.getElementById('capture-frame-btn');
            if (!recordBtn) return;

            if (recording) {
                recordBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Video';
                recordBtn.classList.add('recording');
                if (captureBtn) captureBtn.disabled = true;
            } else {
                recordBtn.innerHTML = '<i class="fas fa-dot-circle"></i> Start Video';
                recordBtn.classList.remove('recording');
                if (captureBtn) captureBtn.disabled = false;
            }
        }

        function stopCameraRecording(skipUpload = false) {
            if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                isRecording = false;
                updateRecordButton(false);
                return;
            }

            shouldUploadRecording = !skipUpload;
            try {
                mediaRecorder.stop();
            } catch (err) {
                console.warn('Failed to stop recording cleanly', err);
            }
            isRecording = false;
            updateRecordButton(false);
            if (skipUpload) {
                recordedChunks = [];
            }
        }

        function startCameraRecording() {
            if (!cameraStream) {
                setCameraStatus('Please allow camera access before recording.', 'error');
                return;
            }
            if (typeof MediaRecorder === 'undefined') {
                setCameraStatus('Recording is not supported in this browser.', 'error');
                return;
            }

            recordedChunks = [];
            shouldUploadRecording = true;

            const options = {};
            if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                options.mimeType = 'video/webm;codecs=vp9';
            } else if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                options.mimeType = 'video/webm;codecs=vp8';
            }

            try {
                mediaRecorder = new MediaRecorder(cameraStream, options);
            } catch (err) {
                console.error('Failed to start recorder', err);
                setCameraStatus('Unable to start recording. Try a different browser.', 'error');
                return;
            }

            mediaRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const mimeType = (options && options.mimeType) || (recordedChunks[0] && recordedChunks[0].type) || 'video/webm';
                const blob = new Blob(recordedChunks, { type: mimeType });
                if (!blob.size || !shouldUploadRecording) {
                    recordedChunks = [];
                    return;
                }

                const file = new File([blob], `camera-recording-${Date.now()}.webm`, { type: blob.type || 'video/webm' });
                recordedChunks = [];
                setCameraStatus('Uploading recording...', 'ready');
                handleFileSelect(file);
                closeCameraModal();
            };

            mediaRecorder.start();
            isRecording = true;
            updateRecordButton(true);
            setCameraStatus('Recording... click stop when ready.', 'ready');
        }

        async function toggleCameraRecording() {
            if (isRecording) {
                stopCameraRecording(false);
                return;
            }

            const stream = await ensureCameraStream();
            if (!stream) return;

            startCameraRecording();
        }

        // File processing (images/videos go to backend; GLB/GLTF/JSON load locally)
        async function handleFileSelect(file) {
            if (!file) return;
            const lowerName = file.name.toLowerCase();
            const isLocalPointCloud = lowerName.endsWith('.glb') || lowerName.endsWith('.gltf') || lowerName.endsWith('.json');

            if (isLocalPointCloud) {
                loadLocalGLB(file);
                return;
            }

            // Otherwise: send to backend for inference
            // Check if model is ready
            const statusResponse = await fetch('/api/model_status');
            const statusData = await statusResponse.json();

            if (statusData.status !== 'ready') {
                alert('Please load a model first by clicking "Select Model" and then "Load Model"');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('resolution', viewerConfig.processRes);
            formData.append('max_points', viewerConfig.maxPoints);
            formData.append('process_res_method', viewerConfig.processResMethod);
            formData.append('align_to_input_ext_scale', viewerConfig.alignToInputScale);
            formData.append('infer_gs', viewerConfig.inferGS);
            formData.append('export_feat_layers', viewerConfig.exportFeatLayers);
            formData.append('conf_thresh_percentile', viewerConfig.confidencePercentile);
            formData.append('apply_confidence_filter', viewerConfig.applyConfidenceFilter);
            formData.append('include_confidence', viewerConfig.includeConfidence);
            formData.append('show_cameras', viewerConfig.showCameras);
            formData.append('feat_vis_fps', viewerConfig.featVisFps);

            document.getElementById('model-status-text').textContent = 'Uploading...';

            try {
                const response = await fetch('/api/process', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok && data.pointcloud) {
                    // Direct load (e.g., server-side GLB/JSON upload bypassing inference)
                    loadPointCloud(data.pointcloud);
                    document.getElementById('model-status-text').textContent = 'Model: Ready';
                    document.getElementById('export-btn').disabled = false;
                    document.getElementById('floor-btn').disabled = false;
                    document.getElementById('manual-floor-btn').disabled = false;
                    document.getElementById('camera-mode-btn').disabled = false;
                    document.getElementById('reset-btn').disabled = false;
                    return;
                } else if (response.ok && data.job_id) {
                    currentJobId = data.job_id;
                    document.getElementById('model-status-text').textContent = 'Processing...';
                    pollJobStatus();
                } else {
                    alert('Error: ' + (data.error || 'Unknown error'));
                    document.getElementById('model-status-text').textContent = 'Model: Ready';
                }
            } catch (error) {
                console.error('Upload error:', error);
                alert('Failed to upload file. Check console for details.');
                document.getElementById('model-status-text').textContent = 'Model: Ready';
            }
        }

        function loadLocalGLB(file) {
            document.getElementById('model-status-text').textContent = 'Loading local point cloud...';
            const loader = new THREE.GLTFLoader();
            const url = URL.createObjectURL(file);

            loader.load(url, (gltf) => {
                // Remove existing point cloud
                if (pointCloud) {
                    scene.remove(pointCloud);
                    pointCloud = null;
                }
                removeMesh();

                let loadedPoints = null;
                let numPoints = 0;

                // Simply find the Points object in the scene and use it directly
                gltf.scene.traverse((child) => {
                    if (child.isPoints) {
                        loadedPoints = child;
                        // Ensure material has proper settings for vertex colors
                        if (child.material) {
                            child.material.vertexColors = true;
                            child.material.size = child.material.size || 0.01;
                            child.material.needsUpdate = true;
                        }
                        if (child.geometry && child.geometry.attributes.position) {
                            numPoints = child.geometry.attributes.position.count;
                        }
                    }
                });

                // If no Points object found, try to use the whole scene
                if (!loadedPoints) {
                    loadedPoints = gltf.scene;
                    gltf.scene.traverse((child) => {
                        if (child.geometry && child.geometry.attributes.position) {
                            numPoints += child.geometry.attributes.position.count;
                        }
                    });
                }

                // Add the loaded GLB directly to the scene
                pointCloud = loadedPoints;
                scene.add(pointCloud);

                // Prepare color caches for hover/select highlighting
                if (pointCloud && pointCloud.isPoints && pointCloud.geometry?.attributes?.color) {
                    const colorAttr = pointCloud.geometry.attributes.color;
                    originalColorArray = new Float32Array(colorAttr.array);
                    baseColorArray = new Float32Array(colorAttr.array);
                } else {
                    originalColorArray = null;
                    baseColorArray = null;
                }
                hoveredIndices = [];
                selectedIndices = [];
                hoveredLowestIndex = null;
                selectedLowestIndex = null;
                selectedAnchorPoint = null;

                document.getElementById('points-count').textContent = `Points: ${numPoints.toLocaleString()}`;
                document.getElementById('model-status-text').textContent = 'Model: Ready';
                document.getElementById('export-btn').disabled = false;
                document.getElementById('floor-btn').disabled = false;
                document.getElementById('manual-floor-btn').disabled = false;
                document.getElementById('camera-mode-btn').disabled = false;
                document.getElementById('reset-btn').disabled = false;

                URL.revokeObjectURL(url);
            }, undefined, (err) => {
                console.error('GLB load error:', err);
                alert('Failed to load GLB. See console for details.');
                document.getElementById('model-status-text').textContent = 'Model: Ready';
                URL.revokeObjectURL(url);
            });
        }

        async function pollJobStatus() {
            const interval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/job/${currentJobId}`);
                    const data = await response.json();

                    if (data.status === 'completed') {
                        clearInterval(interval);
                        loadPointCloud(data.pointcloud);
                        document.getElementById('model-status-text').textContent = 'Model: Ready';
                        document.getElementById('export-btn').disabled = false;
                        document.getElementById('floor-btn').disabled = false;
                        document.getElementById('manual-floor-btn').disabled = false;
                        document.getElementById('camera-mode-btn').disabled = false;
                        document.getElementById('reset-btn').disabled = false;
                    } else if (data.status === 'error') {
                        clearInterval(interval);
                        alert('Processing failed: ' + (data.error || 'Unknown error'));
                        document.getElementById('model-status-text').textContent = 'Model: Ready';
                    }
                } catch (error) {
                    console.error('Status polling error:', error);
                }
            }, 1000);
        }

        function applyConfigToPointCloudData(rawData) {
            if (!rawData) return null;
            if (!viewerConfig.fillSparse) {
                return rawData;
            }
            return densifyPointCloudData(rawData);
        }

        function densifyPointCloudData(rawData) {
            const baseVertices = (rawData.vertices || []).slice();
            if (!baseVertices.length) return rawData;

            const baseColors = (
                rawData.colors && rawData.colors.length
                    ? rawData.colors.slice()
                    : baseVertices.map(() => [255, 255, 255])
            );

            const farIndices = [];
            const targetDistance = Math.max(0.1, viewerConfig.sparseFillDistance);
            baseVertices.forEach((v, idx) => {
                const dist = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
                if (dist > targetDistance) farIndices.push(idx);
            });

            if (!farIndices.length || viewerConfig.sparseFillNewPoints <= 0) {
                return rawData;
            }

            const newVertices = baseVertices.slice();
            const newColors = baseColors.slice();
            const sampleCount = Math.min(viewerConfig.sparseFillNewPoints, farIndices.length);

            for (let i = 0; i < sampleCount; i++) {
                const anchorIdx = farIndices[Math.floor(Math.random() * farIndices.length)];
                const neighborIndices = [];
                const neighborTotal = Math.max(1, viewerConfig.sparseFillNeighbors);
                for (let n = 0; n < neighborTotal; n++) {
                    neighborIndices.push(farIndices[Math.floor(Math.random() * farIndices.length)]);
                }

                const anchor = baseVertices[anchorIdx];
                const neighborAvg = neighborIndices.reduce((acc, idx) => {
                    const v = baseVertices[idx];
                    acc[0] += v[0];
                    acc[1] += v[1];
                    acc[2] += v[2];
                    return acc;
                }, [0, 0, 0]).map(sum => sum / neighborIndices.length);

                const newPoint = [
                    (anchor[0] + neighborAvg[0]) / 2,
                    (anchor[1] + neighborAvg[1]) / 2,
                    (anchor[2] + neighborAvg[2]) / 2
                ];

                const anchorColor = baseColors[anchorIdx] || [255, 255, 255];
                const neighborColor = neighborIndices.reduce((acc, idx) => {
                    const c = baseColors[idx] || [255, 255, 255];
                    acc[0] += c[0];
                    acc[1] += c[1];
                    acc[2] += c[2];
                    return acc;
                }, [0, 0, 0]).map(sum => sum / neighborIndices.length);

                const newColor = [
                    (anchorColor[0] + neighborColor[0]) / 2,
                    (anchorColor[1] + neighborColor[1]) / 2,
                    (anchorColor[2] + neighborColor[2]) / 2
                ];

                newVertices.push(newPoint);
                newColors.push(newColor);
            }

            return {
                vertices: newVertices,
                colors: newColors,
                metadata: {
                    ...(rawData.metadata || {}),
                    num_points: newVertices.length,
                    dense_fill: true
                }
            };
        }

        function createPointsMaterial() {
            const material = new THREE.PointsMaterial({
                size: viewerConfig.pointSize,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                depthWrite: false
            });

            material.onBeforeCompile = (shader) => {
                if (viewerConfig.pointShape === 'circle') {
                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <alphatest_fragment>',
                        'if (length(gl_PointCoord - 0.5) > 0.5) discard;\n#include <alphatest_fragment>'
                    );
                }
            };
            material.needsUpdate = true;
            return material;
        }

        function applyPointMaterialSettings() {
            if (!pointCloud || !pointCloud.material) return;
            const oldMaterial = pointCloud.material;
            const newMaterial = createPointsMaterial();
            pointCloud.material = newMaterial;
            if (oldMaterial.dispose) oldMaterial.dispose();
        }

        function removeMesh() {
            if (meshObject) {
                scene.remove(meshObject);
                if (meshObject.geometry) meshObject.geometry.dispose();
                if (meshObject.material && meshObject.material.dispose) {
                    meshObject.material.dispose();
                }
                meshObject = null;
            }
        }

        function buildMeshFromActiveCloud() {
            if (!viewerConfig.generateMesh || !activePointCloudData) return;
            removeMesh();

            const vertices = activePointCloudData.vertices || [];
            if (!vertices.length) return;

            const baseColors = (
                activePointCloudData.colors && activePointCloudData.colors.length
                    ? activePointCloudData.colors
                    : vertices.map(() => [255, 255, 255])
            );

            const sampleCap = 5000;
            const sampleCount = Math.min(
                Math.max(500, viewerConfig.meshSamplePoints),
                Math.min(vertices.length, sampleCap)
            );
            const sampleIndices = new Set();
            while (sampleIndices.size < sampleCount) {
                sampleIndices.add(Math.floor(Math.random() * vertices.length));
            }

            const points = [];
            const colors = [];
            sampleIndices.forEach((idx) => {
                const v = vertices[idx];
                const c = baseColors[idx] || [255, 255, 255];
                points.push(new THREE.Vector3(v[0], v[1], v[2]));
                colors.push([c[0] / 255, c[1] / 255, c[2] / 255]);
            });

            const neighborCount = Math.min(10, points.length - 1);
            const neighborMap = [];
            for (let i = 0; i < points.length; i++) {
                const center = points[i];
                const distances = [];
                for (let j = 0; j < points.length; j++) {
                    if (i === j) continue;
                    const dist = center.distanceToSquared(points[j]);
                    distances.push({ j, dist });
                }
                distances.sort((a, b) => a.dist - b.dist);
                neighborMap[i] = distances.slice(0, neighborCount).map(d => d.j);
            }

            const indices = [];
            const triKeys = new Set();

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const neighbors = neighborMap[i];
                if (neighbors.length < 2) continue;

                const v1 = points[neighbors[0]].clone().sub(p);
                const v2 = points[neighbors[1]].clone().sub(p);
                const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                if (normal.lengthSq() < 1e-6) {
                    normal.set(0, 1, 0);
                }

                const u = Math.abs(normal.x) < 0.9
                    ? new THREE.Vector3(1, 0, 0).cross(normal).normalize()
                    : new THREE.Vector3(0, 1, 0).cross(normal).normalize();
                const v = new THREE.Vector3().crossVectors(normal, u);

                const ordered = neighbors.map(idx => {
                    const rel = points[idx].clone().sub(p);
                    const proj = rel.sub(normal.clone().multiplyScalar(rel.dot(normal)));
                    const angle = Math.atan2(proj.dot(v), proj.dot(u));
                    return { idx, angle };
                }).sort((a, b) => a.angle - b.angle);

                for (let t = 0; t < ordered.length; t++) {
                    const a = ordered[t].idx;
                    const b = ordered[(t + 1) % ordered.length].idx;
                    if (a === b || a === i || b === i) continue;
                    const key = [i, a, b].sort((x, y) => x - y).join('-');
                    if (triKeys.has(key)) continue;
                    triKeys.add(key);
                    indices.push(i, a, b);
                }
            }

            if (indices.length === 0) return;

            const geometry = new THREE.BufferGeometry();
            const positionArray = new Float32Array(points.length * 3);
            const colorArray = new Float32Array(points.length * 3);
            for (let i = 0; i < points.length; i++) {
                positionArray[i * 3] = points[i].x;
                positionArray[i * 3 + 1] = points[i].y;
                positionArray[i * 3 + 2] = points[i].z;
                colorArray[i * 3] = colors[i][0];
                colorArray[i * 3 + 1] = colors[i][1];
                colorArray[i * 3 + 2] = colors[i][2];
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                flatShading: false,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });

            meshObject = new THREE.Mesh(geometry, material);
            scene.add(meshObject);
        }

        function rebuildPointCloudWithConfig() {
            if (!sourcePointCloudData) return;
            loadPointCloud(sourcePointCloudData, {preserveSource: true});
        }

        function colorAttrToByteTriplets(attr) {
            if (!attr) return [];
            const colors = [];
            let maxVal = 0;
            for (let i = 0; i < attr.count; i++) {
                const r = attr.getX(i) || 0;
                const g = attr.getY(i) || 0;
                const b = attr.getZ(i) || 0;
                maxVal = Math.max(maxVal, r, g, b);
                colors.push([r, g, b]);
            }
            const needsUpscale = attr.normalized || maxVal <= 1.01;
            if (needsUpscale) {
                for (let i = 0; i < colors.length; i++) {
                    colors[i] = colors[i].map(v => v * 255);
                }
            }
            return colors;
        }

        function textureToColors(geometry, texture) {
            if (!geometry || !texture || !texture.image || !geometry.attributes.uv) return [];
            const img = texture.image;
            const uvAttr = geometry.attributes.uv;
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            const colors = new Array(uvAttr.count);
            const w = canvas.width;
            const h = canvas.height;
            for (let i = 0; i < uvAttr.count; i++) {
                const u = uvAttr.getX(i);
                const v = uvAttr.getY(i);
                const px = Math.min(w - 1, Math.max(0, Math.floor(u * (w - 1))));
                const py = Math.min(h - 1, Math.max(0, Math.floor((1 - v) * (h - 1))));
                const idx = (py * w + px) * 4;
                colors[i] = [data[idx], data[idx + 1], data[idx + 2]];
            }
            return colors;
        }

        function extractColorsFromGeometry(geometry, material) {
            if (!geometry || !geometry.attributes?.position) return [];

            const colorAttr = geometry.attributes.color;
            if (colorAttr && colorAttr.count) {
                return colorAttrToByteTriplets(colorAttr);
            }

            if (material && material.map) {
                const texColors = textureToColors(geometry, material.map);
                if (texColors.length) return texColors;
            }

            if (material && material.color) {
                const c = material.color;
                const count = geometry.attributes.position.count;
                return new Array(count).fill([c.r * 255, c.g * 255, c.b * 255]);
            }

            return [];
        }

        function injectTextureVertexColors(geometry, material) {
            if (!geometry || !material || !material.map || geometry.attributes.color) return;
            const uvAttr = geometry.attributes.uv;
            if (!uvAttr) return;
            const img = material.map.image;
            if (!img || !img.width || !img.height) return;

            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

            const colors = new Float32Array(uvAttr.count * 3);
            const w = canvas.width;
            const h = canvas.height;

            for (let i = 0; i < uvAttr.count; i++) {
                const u = uvAttr.getX(i);
                const v = uvAttr.getY(i);
                const px = Math.min(w - 1, Math.max(0, Math.floor(u * (w - 1))));
                const py = Math.min(h - 1, Math.max(0, Math.floor((1 - v) * (h - 1))));
                const idx = (py * w + px) * 4;
                colors[i * 3] = data[idx] / 255;
                colors[i * 3 + 1] = data[idx + 1] / 255;
                colors[i * 3 + 2] = data[idx + 2] / 255;
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        }

        function loadPointCloud(data, options = {}) {
            const { preserveSource = false } = options;
            try {
                const shouldUpdateSource = !preserveSource || !sourcePointCloudData;
                if (shouldUpdateSource) {
                    sourcePointCloudData = data;
                }

                const workingSource = preserveSource ? (sourcePointCloudData || data) : data;
                const processed = applyConfigToPointCloudData(workingSource);
                if (!processed.metadata) {
                    processed.metadata = {};
                }
                if (!processed.metadata.num_points) {
                    processed.metadata.num_points = processed.vertices.length;
                }
                activePointCloudData = processed;
                originalPointCloudData = processed;

                // Remove existing point cloud
                if (pointCloud) {
                    scene.remove(pointCloud);
                    if (pointCloud.geometry) pointCloud.geometry.dispose();
                    if (pointCloud.material && pointCloud.material.dispose) {
                        pointCloud.material.dispose();
                    }
                }

                removeMesh();

                // Create geometry
                const geometry = new THREE.BufferGeometry();
                const vertices = new Float32Array(processed.vertices.flat());
                const normalizedColorsSource = (
                    processed.colors && processed.colors.length
                        ? processed.colors
                        : processed.vertices.map(() => [255, 255, 255])
                );
                if (!processed.colors || !processed.colors.length) {
                    processed.colors = normalizedColorsSource;
                }
                const colors = new Float32Array(normalizedColorsSource.flat().map(c => c / 255));

                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                // Cache color buffers for fast restore during hover/select highlighting
                originalColorArray = new Float32Array(colors);
                baseColorArray = new Float32Array(colors);
                hoveredIndices = [];
                selectedIndices = [];
                hoveredLowestIndex = null;
                selectedLowestIndex = null;
                selectedAnchorPoint = null;

                // Create material
                const material = createPointsMaterial();

                // Create point cloud
                pointCloud = new THREE.Points(geometry, material);
                scene.add(pointCloud);

                // Remember the merged cloud so we can toggle per-frame-only view during video playback
                if (processed.metadata?.is_video && typeof videoPlayer !== 'undefined') {
                    videoPlayer.setCombinedPointCloud(pointCloud, processed);
                }

                // Update stats
                const numPoints = processed.metadata?.num_points || processed.vertices.length;
                document.getElementById('points-count').textContent = `Points: ${numPoints.toLocaleString()}`;
                document.getElementById('model-status-text').textContent = 'Model: Ready';
                document.getElementById('export-btn').disabled = false;
                document.getElementById('floor-btn').disabled = false;
                document.getElementById('manual-floor-btn').disabled = false;
                document.getElementById('camera-mode-btn').disabled = false;
                document.getElementById('reset-btn').disabled = false;

                // Check if this is a video and load video player
                if (processed.metadata?.is_video) {
                    console.log('Video detected, loading video player...');
                    setTimeout(async () => {
                        const loaded = await videoPlayer.loadVideo();
                        if (loaded) {
                            console.log('Video player initialized successfully');
                        }
                    }, 500);
                } else {
                    // Hide video controls if showing
                    videoPlayer.reset();
                }

                // Center camera
                const box = new THREE.Box3().setFromObject(pointCloud);
                const center = box.getCenter(new THREE.Vector3());
                camera.lookAt(center);
                if (controls) controls.update(0);

                hydrateModelStatus();
                if (viewerConfig.generateMesh) {
                    buildMeshFromActiveCloud();
                }

                console.log('Point cloud loaded successfully');
            } catch (error) {
                console.error('Error loading point cloud:', error);
                alert('Failed to load point cloud. Check console for details.');
            }
        }

        // Floor alignment (automatic)
        async function alignFloor() {
            try {
                document.getElementById('model-status-text').textContent = 'Aligning floor...';
                const response = await fetch('/api/floor_align', {method: 'POST'});
                const data = await response.json();

                if (response.ok) {
                    loadPointCloud(data.pointcloud);
                    alert('Floor aligned successfully! The floor is now at y=0.');
                    document.getElementById('model-status-text').textContent = 'Model: Ready';
                } else {
                    alert('Error: ' + (data.error || 'Failed to align floor'));
                    document.getElementById('model-status-text').textContent = 'Model: Ready';
                }
            } catch (error) {
                console.error('Floor alignment error:', error);
                alert('Failed to align floor. Check console for details.');
                document.getElementById('model-status-text').textContent = 'Model: Ready';
            }
        }

        // Manual floor selection
        const FLOOR_HOVER_RADIUS = 0.45;
        const FLOOR_CLICK_RADIUS = 0.6;
        const MIN_FLOOR_POINTS = 80;
        const HOVER_THROTTLE_MS = 60;
        const PLANE_ALIGN_ROTATION_FACTOR = 1.0; // fully align selected plane to ground
        function toggleManualFloorSelection() {
            manualFloorMode = !manualFloorMode;
            const btn = document.getElementById('manual-floor-btn');
            const text = document.getElementById('manual-floor-text');

            if (manualFloorMode) {
                btn.style.background = 'rgba(59, 130, 246, 0.5)';
                btn.style.borderColor = 'rgba(59, 130, 246, 0.8)';
                text.textContent = 'Click Floor';
                document.getElementById('model-status-text').textContent = 'Hover to preview, click to lock floor points';
                clearHoverHighlight();
                console.log('Manual floor selection mode: ON');
            } else {
                btn.style.background = 'rgba(16, 185, 129, 0.2)';
                btn.style.borderColor = 'rgba(16, 185, 129, 0.5)';
                text.textContent = 'Select Floor';
                document.getElementById('model-status-text').textContent = 'Model: Ready';
                clearHighlightedPoints();
                selectedPoints = [];
                console.log('Manual floor selection mode: OFF');
            }
        }

        function collectPointsWithinRadius(centerPoint, radius, options = {}) {
            const { collectVectors = true } = options;
            const points = [];
            const indices = [];
            let lowestIndex = null;
            let lowestY = Infinity;
            let lowestPoint = null;

            if (!pointCloud || radius <= 0) {
                return { points, indices, lowestIndex, lowestPoint };
            }

            const positionAttr = pointCloud.geometry?.attributes?.position;
            if (!positionAttr || !positionAttr.array) {
                return { points, indices, lowestIndex, lowestPoint };
            }

            const positions = positionAttr.array;
            const radiusSq = radius * radius;

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];

                const dx = x - centerPoint.x;
                const dy = y - centerPoint.y;
                const dz = z - centerPoint.z;
                const distSq = dx * dx + dy * dy + dz * dz;

                if (distSq <= radiusSq) {
                    const idx = i / 3;
                    indices.push(idx);
                    if (collectVectors) {
                        const v = new THREE.Vector3(x, y, z);
                        points.push(v);
                        if (y < lowestY) {
                            lowestPoint = v;
                        }
                    } else if (y < lowestY) {
                        lowestPoint = { x, y, z };
                    }
                    if (y < lowestY) {
                        lowestY = y;
                        lowestIndex = idx;
                    }
                }
            }

            return { points, indices, lowestIndex, lowestPoint };
        }

        function onMouseMove(event) {
            if (!pointCloud) return;
            if (!manualFloorMode) {
                clearHoverHighlight();
                return;
            }

            const now = performance.now();
            if (now - lastHoverTime < HOVER_THROTTLE_MS) return;
            lastHoverTime = now;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(pointCloud, true);
            if (!intersects.length) {
                clearHoverHighlight();
                return;
            }

            const { indices, lowestIndex } = collectPointsWithinRadius(
                intersects[0].point,
                FLOOR_HOVER_RADIUS,
                { collectVectors: false }
            );

            if (!indices.length) {
                clearHoverHighlight();
                return;
            }

            applyHoverHighlight(indices, lowestIndex);
        }

        function onMouseClick(event) {
            if (!manualFloorMode || !pointCloud) return;

            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update raycaster
            raycaster.setFromCamera(mouse, camera);

            // Check for intersections
            const intersects = raycaster.intersectObject(pointCloud, true);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const point = intersect.point;

                console.log('Clicked point:', point);

                // Find nearby points
                const { points, indices, lowestIndex, lowestPoint } = collectPointsWithinRadius(
                    point,
                    FLOOR_CLICK_RADIUS
                );

                if (!indices.length) {
                    clearHoverHighlight();
                    clearHighlightedPoints();
                    return;
                }

                selectedPoints = points;
                selectedAnchorPoint = lowestPoint ? lowestPoint.clone() : null;
                applySelectionHighlight(indices, lowestIndex);

                const status = `Selected ${indices.length} points (min y anchor shown in white)`;
                document.getElementById('model-status-text').textContent = status;

                // Fit plane and align once we have enough support
                if (selectedPoints.length >= MIN_FLOOR_POINTS) {
                    applyManualFloorAlignment();
                } else {
                    console.log(`Need at least ${MIN_FLOOR_POINTS} points to fit plane`);
                }
            }
        }

        function clearHighlightedPoints() {
            if (!pointCloud) return;
            const colorAttr = pointCloud.geometry?.attributes?.color;
            if (!originalColorArray && colorAttr?.array) {
                originalColorArray = new Float32Array(colorAttr.array);
            }
            if (!originalColorArray || !colorAttr?.array) return;

            const colors = colorAttr.array;
            colors.set(originalColorArray);
            baseColorArray = new Float32Array(originalColorArray);
            hoveredIndices = [];
            selectedIndices = [];
            hoveredLowestIndex = null;
            selectedLowestIndex = null;
            selectedAnchorPoint = null;
            selectedPoints = [];

            pointCloud.geometry.attributes.color.needsUpdate = true;
            console.log('Original colors restored');
        }

        function applyHoverHighlight(indices, lowestIndex) {
            if (!pointCloud || !indices.length) return;
            const colorAttr = pointCloud.geometry?.attributes?.color;
            if (!colorAttr || !colorAttr.array) return;
            const colors = colorAttr.array;

            if (!baseColorArray) {
                baseColorArray = new Float32Array(colors);
            }
            if (!originalColorArray) {
                originalColorArray = new Float32Array(colors);
            }

            // Restore previous hover region from base (which already includes selections)
            if (hoveredIndices.length && baseColorArray) {
                hoveredIndices.forEach(idx => {
                    const i3 = idx * 3;
                    colors[i3] = baseColorArray[i3];
                    colors[i3 + 1] = baseColorArray[i3 + 1];
                    colors[i3 + 2] = baseColorArray[i3 + 2];
                });
            }

            const hoverColor = [0.8, 0.9, 1.0];
            const anchorColor = [1.0, 1.0, 1.0];

            indices.forEach(idx => {
                const i3 = idx * 3;
                const c = idx === lowestIndex ? anchorColor : hoverColor;
                colors[i3] = c[0];
                colors[i3 + 1] = c[1];
                colors[i3 + 2] = c[2];
            });

            hoveredIndices = indices;
            hoveredLowestIndex = lowestIndex;
            pointCloud.geometry.attributes.color.needsUpdate = true;
        }

        function clearHoverHighlight() {
            if (!pointCloud || !hoveredIndices.length) return;
            const colorAttr = pointCloud.geometry?.attributes?.color;
            if (!colorAttr || !colorAttr.array) return;
            const colors = colorAttr.array;
            const source = baseColorArray || originalColorArray;
            if (source) {
                hoveredIndices.forEach(idx => {
                    const i3 = idx * 3;
                    colors[i3] = source[i3];
                    colors[i3 + 1] = source[i3 + 1];
                    colors[i3 + 2] = source[i3 + 2];
                });
            }
            hoveredIndices = [];
            hoveredLowestIndex = null;
            pointCloud.geometry.attributes.color.needsUpdate = true;
        }

        function applySelectionHighlight(indices, lowestIndex) {
            if (!pointCloud || !indices.length) return;
            const colorAttr = pointCloud.geometry?.attributes?.color;
            if (!colorAttr || !colorAttr.array) return;
            const colors = colorAttr.array;

            if (!originalColorArray) {
                originalColorArray = new Float32Array(colors);
            }
            if (!baseColorArray) {
                baseColorArray = new Float32Array(colors);
            }

            // Restore any previous selection back to original colors
            if (selectedIndices.length && originalColorArray) {
                selectedIndices.forEach(idx => {
                    const i3 = idx * 3;
                    colors[i3] = originalColorArray[i3];
                    colors[i3 + 1] = originalColorArray[i3 + 1];
                    colors[i3 + 2] = originalColorArray[i3 + 2];
                    if (baseColorArray) {
                        baseColorArray[i3] = originalColorArray[i3];
                        baseColorArray[i3 + 1] = originalColorArray[i3 + 1];
                        baseColorArray[i3 + 2] = originalColorArray[i3 + 2];
                    }
                });
            }

            clearHoverHighlight();

            const selectColor = [0.65, 1.0, 0.7];
            const anchorColor = [1.0, 1.0, 1.0];

            indices.forEach(idx => {
                const i3 = idx * 3;
                const c = idx === lowestIndex ? anchorColor : selectColor;
                colors[i3] = c[0];
                colors[i3 + 1] = c[1];
                colors[i3 + 2] = c[2];
                if (baseColorArray) {
                    baseColorArray[i3] = c[0];
                    baseColorArray[i3 + 1] = c[1];
                    baseColorArray[i3 + 2] = c[2];
                }
            });

            selectedIndices = indices;
            selectedLowestIndex = lowestIndex;
            pointCloud.geometry.attributes.color.needsUpdate = true;
        }

        async function syncManualAlignmentToBackend(rotationQuat, anchorY) {
            if (!rotationQuat) return;
            const payload = {
                rotation: [rotationQuat.x, rotationQuat.y, rotationQuat.z, rotationQuat.w],
                translation: [0, -anchorY, 0]
            };

            try {
                const response = await fetch('/api/floor_align/manual', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const txt = await response.text();
                    console.warn('Manual floor sync failed', response.status, txt);
                    document.getElementById('model-status-text').textContent = 'Model: Ready (local align only)';
                    return;
                }

                const data = await response.json();
                if (data.pointcloud) {
                    // Reload to ensure viewer + backend are in sync for export
                    loadPointCloud(data.pointcloud);
                }
                document.getElementById('model-status-text').textContent = 'Model: Ready';
                console.log('Manual floor alignment synced to backend');
            } catch (err) {
                console.warn('Manual floor sync error', err);
                document.getElementById('model-status-text').textContent = 'Model: Ready (local align only)';
            }
        }

        function smallestEigenVectorFromCov(xx, xy, xz, yy, yz, zz) {
            // Symmetric 3x3 Jacobi eigen decomposition; return eigenvector of smallest eigenvalue
            let a = [
                [xx, xy, xz],
                [xy, yy, yz],
                [xz, yz, zz]
            ];
            let v = [
                [1, 0, 0],
                [0, 1, 0],
                [0, 0, 1]
            ];

            const MAX_ITERS = 20;
            for (let iter = 0; iter < MAX_ITERS; iter++) {
                // Find largest off-diagonal element
                let p = 0, q = 1;
                let maxOff = Math.abs(a[p][q]);
                const off02 = Math.abs(a[0][2]);
                const off12 = Math.abs(a[1][2]);
                if (off02 > maxOff) { maxOff = off02; p = 0; q = 2; }
                if (off12 > maxOff) { maxOff = off12; p = 1; q = 2; }

                if (maxOff < 1e-10) break;

                const app = a[p][p];
                const aqq = a[q][q];
                const apq = a[p][q];
                const phi = 0.5 * Math.atan2(2 * apq, aqq - app);
                const c = Math.cos(phi);
                const s = Math.sin(phi);

                // Rotate A in p-q plane
                for (let k = 0; k < 3; k++) {
                    const apk = a[p][k];
                    const aqk = a[q][k];
                    a[p][k] = c * apk - s * aqk;
                    a[q][k] = s * apk + c * aqk;
                }
                for (let k = 0; k < 3; k++) {
                    const akp = a[k][p];
                    const akq = a[k][q];
                    a[k][p] = c * akp - s * akq;
                    a[k][q] = s * akp + c * akq;
                }
                a[p][q] = a[q][p] = 0;
                a[p][p] = c * c * app - 2 * s * c * apq + s * s * aqq;
                a[q][q] = s * s * app + 2 * s * c * apq + c * c * aqq;

                // Rotate eigenvector matrix V
                for (let k = 0; k < 3; k++) {
                    const vkp = v[k][p];
                    const vkq = v[k][q];
                    v[k][p] = c * vkp - s * vkq;
                    v[k][q] = s * vkp + c * vkq;
                }
            }

            const eigenvalues = [a[0][0], a[1][1], a[2][2]];
            let minIdx = 0;
            if (eigenvalues[1] < eigenvalues[minIdx]) minIdx = 1;
            if (eigenvalues[2] < eigenvalues[minIdx]) minIdx = 2;

            return new THREE.Vector3(v[0][minIdx], v[1][minIdx], v[2][minIdx]);
        }

        function fitPlaneToPoints(points) {
            // Fit plane using least squares via covariance + eigen decomposition
            const n = points.length;
            if (n < 3) return null;

            // Calculate centroid
            const centroid = new THREE.Vector3();
            points.forEach(p => centroid.add(p));
            centroid.divideScalar(n);

            // Build covariance matrix
            let xx = 0, xy = 0, xz = 0;
            let yy = 0, yz = 0, zz = 0;

            points.forEach(p => {
                const dx = p.x - centroid.x;
                const dy = p.y - centroid.y;
                const dz = p.z - centroid.z;

                xx += dx * dx;
                xy += dx * dy;
                xz += dx * dz;
                yy += dy * dy;
                yz += dy * dz;
                zz += dz * dz;
            });

            const normal = smallestEigenVectorFromCov(xx, xy, xz, yy, yz, zz);
            if (!normal || !isFinite(normal.lengthSq()) || normal.lengthSq() < 1e-12) {
                return null;
            }
            normal.normalize();

            // Ensure normal points upward
            if (normal.y < 0) {
                normal.multiplyScalar(-1);
            }

            // Plane offset
            const d = -normal.dot(centroid);

            return { normal, d, centroid };
        }

        function applyManualFloorAlignment() {
            if (selectedPoints.length < MIN_FLOOR_POINTS) {
                alert(`Not enough points selected. Click on a larger floor area (need ${MIN_FLOOR_POINTS}+).`);
                return;
            }

            document.getElementById('model-status-text').textContent = 'Fitting plane...';

            // Fit plane to selected points
            const plane = fitPlaneToPoints(selectedPoints);

            if (!plane) {
                alert('Failed to fit plane to selected points.');
                document.getElementById('model-status-text').textContent = 'Model: Ready';
                return;
            }

            console.log('Fitted plane normal:', plane.normal);
            console.log('Plane centroid:', plane.centroid);

            // Create rotation to align plane with XZ (y=0)
            const targetNormal = new THREE.Vector3(0, 1, 0);
            const rotationQuat = new THREE.Quaternion().setFromUnitVectors(plane.normal, targetNormal);

            // Apply rotation to all points
            const positionAttr = pointCloud.geometry?.attributes?.position;
            if (!positionAttr || !positionAttr.array) {
                alert('Current point cloud does not expose positions for alignment.');
                return;
            }
            const positions = positionAttr.array;
            const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(rotationQuat);

            for (let i = 0; i < positions.length; i += 3) {
                const point = new THREE.Vector3(
                    positions[i],
                    positions[i + 1],
                    positions[i + 2]
                );

                point.applyMatrix4(rotationMatrix);

                positions[i] = point.x;
                positions[i + 1] = point.y;
                positions[i + 2] = point.z;
            }

            // Bias toward vertical displacement: translate so the average of selected points lands at y=0
            let anchorY = 0;
            if (selectedPoints.length) {
                let sumY = 0;
                selectedPoints.forEach(p => {
                    const rp = p.clone().applyQuaternion(rotationQuat);
                    sumY += rp.y;
                });
                anchorY = sumY / selectedPoints.length;
            } else {
                const rotatedCentroid = plane.centroid.clone().applyQuaternion(rotationQuat);
                anchorY = rotatedCentroid.y;
            }

            for (let i = 1; i < positions.length; i += 3) {
                positions[i] -= anchorY;
            }

            pointCloud.geometry.attributes.position.needsUpdate = true;
            pointCloud.geometry.computeBoundingSphere();

            // Update stored point cloud data with new aligned vertices
            const newVertices = [];
            for (let i = 0; i < positions.length; i += 3) {
                newVertices.push([positions[i], positions[i + 1], positions[i + 2]]);
            }

            if (originalPointCloudData) {
                originalPointCloudData.vertices = newVertices;
            }
            if (activePointCloudData) {
                activePointCloudData.vertices = newVertices;
                if (activePointCloudData.metadata) {
                    activePointCloudData.metadata.num_points = newVertices.length;
                }
            }
            if (sourcePointCloudData) {
                sourcePointCloudData.vertices = newVertices;
                if (sourcePointCloudData.metadata) {
                    sourcePointCloudData.metadata.num_points = newVertices.length;
                }
            }

            // Push manual transform to backend so exports match the viewer
            syncManualAlignmentToBackend(rotationQuat, anchorY);

            // Exit selection mode (this will restore original colors)
            toggleManualFloorSelection();

            alert(`Floor aligned! Used ${selectedPoints.length} points for plane fitting.`);
            document.getElementById('model-status-text').textContent = 'Model: Ready';

            console.log('Manual floor alignment complete');
        }

        // Export GLB
        async function exportGLB() {
            try {
                document.getElementById('model-status-text').textContent = 'Exporting...';
                const glbUrl = `${API_BASE || ''}/api/export/glb`;

                const response = await fetch(glbUrl);
                if (!response.ok) {
                    throw new Error(`Export failed with status ${response.status}`);
                }

                const blob = await response.blob();
                // Try to honor filename from Content-Disposition; fall back to a default
                const disposition = response.headers.get('Content-Disposition') || '';
                let filename = 'point_cloud.glb';
                const utfMatch = disposition.match(/filename\\*=UTF-8''([^;]+)/);
                const plainMatch = disposition.match(/filename=\"?([^\";]+)\"?/);
                if (utfMatch) {
                    filename = decodeURIComponent(utfMatch[1]);
                } else if (plainMatch) {
                    filename = plainMatch[1];
                }

                const downloadUrl = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                window.URL.revokeObjectURL(downloadUrl);

                document.getElementById('model-status-text').textContent = 'Model: Ready';
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export. Check console for details.');
                document.getElementById('model-status-text').textContent = 'Model: Ready';
            }
        }

        // Reset view
        function resetView() {
            camera.position.set(0, CAMERA_HEIGHT, 5);  // Reset to eye level
            camera.lookAt(new THREE.Vector3(0, CAMERA_HEIGHT, 0));
            if (controls) controls.update(0);
        }

        function disableNavigationControls() {
            if (flyControls) flyControls.enabled = false;
            if (orbitControls) orbitControls.enabled = false;
            controls = null;
        }

        function isFPSMode() {
            return activeCameraMode === 'FPS';
        }

        function setCameraMode(mode) {
            if (!CAMERA_MODES.includes(mode)) return;

            activeCameraMode = mode;
            currentCameraModeIndex = CAMERA_MODES.indexOf(mode);

            if (mode === 'FPS') {
                disableNavigationControls();
                updateCameraModeButtonState();
                if (!pointerLocked) {
                    requestPointerLock();
                }
                console.log('FPS Mode activated');
                return;
            }

            if (pointerLocked || pointerLockControls) {
                exitPointerLock();
            }

            disableNavigationControls();

            if (mode === 'FLY' && flyControls) {
                flyControls.enabled = true;
                controls = flyControls;
            } else if (mode === 'ORBIT' && orbitControls) {
                orbitControls.enabled = true;
                controls = orbitControls;
            }

            updateCameraModeButtonState();
            console.log(`${mode} Mode activated`);
        }

        function cycleCameraMode() {
            currentCameraModeIndex = (currentCameraModeIndex + 1) % CAMERA_MODES.length;
            setCameraMode(CAMERA_MODES[currentCameraModeIndex]);
        }

        function updateCameraModeButtonState() {
            const btn = document.getElementById('camera-mode-btn');
            const text = document.getElementById('camera-mode-text');
            if (!btn || !text) return;

            const mode = activeCameraMode;
            const style = CAMERA_MODE_STYLES[mode] || {};
            text.textContent = `${CAMERA_MODE_LABELS[mode] || mode} Mode`;

            if (style.background) btn.style.background = style.background;
            if (style.border) btn.style.borderColor = style.border;
        }

        function setupModalCloseHandler() {
            // Close modal when clicking outside
            window.addEventListener('click', (e) => {
                const modelModal = document.getElementById('model-modal');
                const configModal = document.getElementById('config-modal');
                if (modelModal && e.target === modelModal) {
                    closeModelSelector();
                }
                if (configModal && e.target === configModal) {
                    closeConfigModal();
                }
            });
        }

        function setupManualFloorSelection() {
            // Add click listener for manual floor selection
            if (renderer && renderer.domElement) {
                renderer.domElement.addEventListener('click', onMouseClick, false);
                renderer.domElement.addEventListener('mousemove', onMouseMove, false);
                renderer.domElement.addEventListener('mouseleave', clearHoverHighlight, false);
                console.log('Manual floor selection hover + click handlers registered');
            }
        }

        // ============================================================================
        // VIDEO PLAYBACK AND CAMERA PATH
        // ============================================================================

        /**
         * VideoPlayer - Handles video sequence playback and camera path visualization
         *
         * **Camera Path Derivation from Depth Anything 3:**
         *
         * The camera path represents the 3D trajectory of the camera through space as it
         * captures the video. In Depth Anything 3, camera poses are PREDICTED by a neural
         * network (not computed via traditional SfM/SLAM).
         *
         * **How Camera Poses are Predicted:**
         * 1. **Input**: Video frames → extracted at specified FPS
         * 2. **Feature Extraction**: DinoV2 backbone extracts visual features from each frame
         * 3. **Camera Encoder**: Processes features to create pose-aware tokens
         * 4. **Camera Decoder**: Predicts 9D pose encoding for each frame:
         *    - Translation (t): 3D camera position in world space
         *    - Quaternion (qvec): 4D rotation representation
         *    - Field of View (fov): 2D horizontal and vertical FOV angles
         * 5. **Pose Conversion**: 9D encoding → 4×4 extrinsics matrix (world-to-camera)
         * 6. **Backend Processing**:
         *    - Inverts extrinsics to camera-to-world (c2w)
         *    - Transforms points from camera space to world space
         *    - Stores c2w and world-space points in frame data
         * 7. **Path Construction**: Camera positions extracted from c2w matrices in frames
         *
         * **Coordinate System:**
         * - Model Output: Extrinsics (w2c) predicted by DA3 camera module
         * - Frame Data: c2w matrices (row-major and column-major) + world-space points
         * - Three.js: Column-major c2w matrices (preferred format)
         * - Camera Space: +X right, +Y up, -Z forward (OpenGL/Three.js convention)
         *
         * **Key Features:**
         * - Frame-by-frame point cloud playback
         * - Smooth camera path spline interpolation
         * - Camera frustum visualization at each frame
         * - "Follow camera" mode to match the captured viewpoint
         * - Point cloud transformation from camera space to world space
         *
         * @class VideoPlayer
         */
        class VideoPlayer {
            constructor() {
                this.currentFrame = 0;
                this.videoInfo = null;
                this.isPlaying = false;
                this.isLooping = true;
                this.pointCloudMesh = null;          // Per-frame cloud
                this.playbackTimer = null;
                this.frameBuffer = new Map();
                this.bufferSize = 5;
                this.cameraPathLine = null;
                this.cameraFrustums = [];
                this.cameraOrigins = [];
                this.showCameraPath = false;
                this.followCamera = false;          // Attach viewer camera to the captured path
                this.cameraData = null;
                this.previousCameraState = null;
                this.showFrameOnly = false;          // Hide merged cloud, show current frame only
                this.cameraPathData = null;          // Cached /api/video/camera_path payload
                this.cameraSpline = null;            // Spline for smooth playback
                this.currentCameraHelper = null;     // Helper showing current camera pose
                this.combinedPointCloudMesh = null;  // Merged point cloud from inference
                this.combinedPointCloudData = null;
                this.rawPoseLogged = false;          // Guard so we only dump one raw pose
                this.poseDebugLine = null;           // Optional forward vector debug line
                this.lastPoseDebugFrame = null;
                this.loggedFirstTransform = false;   // Guard for point cloud transform logging
                this.pathProgressMarker = null;      // Animated marker showing current position on path
                this.signFlip = this.loadSignFlip(); // {x,y,z} toggles for manual alignment debugging (points only)
                this.orientationFlips = this.loadOrientationFlips(); // {yaw,pitch,roll} orientation-only flips per camera

                // Scene-wide transformation (applied to entire reconstruction as rigid body)
                this.sceneTransform = {
                    translation: { x: 0, y: 0, z: 0 },
                    rotation: { yaw: 0, pitch: 0, roll: 0 }
                };
            }

            setCombinedPointCloud(mesh, data) {
                this.combinedPointCloudMesh = mesh;
                this.combinedPointCloudData = data;
                this.syncCloudVisibility();
            }

            setToggleState(id, active) {
                const btn = document.getElementById(id);
                if (!btn) return;
                btn.style.background = active
                    ? 'rgba(16, 185, 129, 0.4)'
                    : 'rgba(16, 185, 129, 0.2)';
            }

            syncCloudVisibility() {
                if (this.combinedPointCloudMesh) {
                    this.combinedPointCloudMesh.visible = !this.showFrameOnly;
                }
                if (this.pointCloudMesh) {
                    this.pointCloudMesh.visible = true; // always show the per-frame overlay
                }

                this.setToggleState('video-frame-only-btn', this.showFrameOnly);
            }

            async loadVideo() {
                try {
                    const res = await fetch('/api/video/info');
                    if (!res.ok) {
                        console.log('No video sequence available');
                        return false;
                    }

                    this.videoInfo = await res.json();
                    console.log('Video loaded:', this.videoInfo);

                    // Preload camera path data for helpers and playback
                    await this.ensureCameraPathData();

                    // Reset toggle states for a fresh session
                    this.showFrameOnly = false;
                    this.setToggleState('video-loop-btn', this.isLooping);
                    this.setToggleState('video-camera-path-btn', this.showCameraPath);
                    this.setToggleState('video-follow-cam-btn', this.followCamera);
                    this.setToggleState('video-frame-only-btn', this.showFrameOnly);
                    this.syncCloudVisibility();

                    // Update UI
                    document.getElementById('video-controls').style.display = 'flex';
                    document.getElementById('frame-slider').max = this.videoInfo.num_frames - 1;
                    document.getElementById('fps-display').textContent = `${this.videoInfo.fps} FPS`;
                    this.updateFrameCounter();

                    // Load first frame
                    await this.loadFrame(0);
                    return true;
                } catch (err) {
                    console.error('Failed to load video:', err);
                    return false;
                }
            }

            /**
             * Load and display a specific video frame.
             *
             * **Frame Data Structure:**
             * - vertices: Point positions in WORLD SPACE (already transformed by backend)
             * - colors: RGB colors for each point
             * - camera_pose: Camera-to-world matrix (c2w, row-major nested array)
             * - camera_pose_col_major_flat: Camera-to-world matrix (c2w, column-major flat array, ready for Three.js)
             * - intrinsics: 3x3 camera intrinsics matrix
             *
             * **Processing Steps:**
             * 1. Load frame from buffer (preload if needed)
             * 2. Parse camera pose (already c2w, no inversion needed)
             * 3. Display point cloud (already in world space, no transformation needed)
             * 4. Update visualization (frustum, path highlight, etc.)
             */
            async loadFrame(frameIndex) {
                if (!this.videoInfo) return;

                // Ensure frame is in buffer
                if (!this.frameBuffer.has(frameIndex)) {
                    await this.preloadFrames(frameIndex);
                }

                const frame = this.frameBuffer.get(frameIndex);
                if (!frame) {
                    console.error('❌ Frame not in buffer:', frameIndex);
                    return;
                }

                // Parse camera pose (backend provides c2w, NOT w2c)
                // Backend always provides camera_pose as c2w (camera-to-world)
                // camera_pose_col_major_flat is the optimal format (column-major, ready for Three.js)
                const shouldLogRawPose = (
                    POSE_DEBUG_CONFIG.logFirstRawPose &&
                    !this.rawPoseLogged &&
                    frameIndex === POSE_DEBUG_CONFIG.rawPoseFrameIndex
                );

                let c2wMatrix;
                if (frame.camera_pose_col_major_flat) {
                    // Optimal: Pre-computed c2w in column-major format (no transpose needed)
                    c2wMatrix = this.poseToMatrix(frame.camera_pose_col_major_flat, {
                        logRaw: shouldLogRawPose,
                        frameIndex,
                        alreadyColumnMajor: true
                    });
                } else if (frame.camera_pose) {
                    // Fallback: Parse c2w in row-major format (needs transpose)
                    c2wMatrix = this.poseToMatrix(frame.camera_pose, {
                        logRaw: shouldLogRawPose,
                        frameIndex,
                        alreadyColumnMajor: false
                    });

                    if (shouldLogRawPose && c2wMatrix) {
                        console.log('✅ Loaded c2w pose for frame', frameIndex);
                    }
                }

                // Store original c2w (before orientation correction)
                const originalC2w = c2wMatrix ? c2wMatrix.clone() : null;

                // Apply manual sign flips/rotations for debugging alignment
                const correctedC2w = this.applyOrientationToMatrix(c2wMatrix);

                // Cache corrected c2w matrix for other functions
                frame._c2w_matrix = correctedC2w;
                frame._c2w = correctedC2w ? correctedC2w.toArray() : null;
                frame._original_c2w = originalC2w;

                this.currentFrame = frameIndex;

                // Re-orient points if orientation correction is applied
                // Points from backend are in world space using original c2w.
                // We need to rotate them to match the corrected camera orientation.
                const needsReorientation = originalC2w && correctedC2w &&
                    !originalC2w.equals(correctedC2w);

                let vertices = frame.vertices;
                if (needsReorientation) {
                    vertices = this.reorientPointsForCorrectedPose(
                        frame.vertices,
                        originalC2w,
                        correctedC2w
                    );
                }

                // Display point cloud (vertices are in world space)
                this.updatePointCloud(vertices, frame.colors, null);

                // Debug: Log point cloud bounds for this frame
                if (POSE_DEBUG_CONFIG.logFirstRawPose && frameIndex === 0 && frame.vertices && frame.vertices.length > 0) {
                    const verts = frame.vertices;
                    const xs = verts.map(v => v[0]);
                    const ys = verts.map(v => v[1]);
                    const zs = verts.map(v => v[2]);
                    console.group('📊 Frame 0 Point Cloud Bounds');
                    console.log('X range:', Math.min(...xs).toFixed(3), 'to', Math.max(...xs).toFixed(3));
                    console.log('Y range:', Math.min(...ys).toFixed(3), 'to', Math.max(...ys).toFixed(3));
                    console.log('Z range:', Math.min(...zs).toFixed(3), 'to', Math.max(...zs).toFixed(3));
                    console.log('Num points:', verts.length);
                    console.groupEnd();
                }

                this.updateFrameCounter();
                this.updateCameraHelper(frame);
                this.syncCloudVisibility();

                // Update slider
                const slider = document.getElementById('frame-slider');
                if (slider) slider.value = frameIndex;

                // Update viewer camera if following mode is enabled
                if (this.followCamera && c2wMatrix && frame.intrinsics) {
                    this.updateViewerCamera(c2wMatrix, frame.intrinsics, { frameIndex });
                }

                // Highlight current camera frustum
                if (this.showCameraPath) {
                    this.highlightCurrentFrustum(frameIndex);
                }

                // Update progress marker along camera path
                this.updatePathProgressMarker(frameIndex);

                // Preload next batch if needed
                if ((frameIndex + 1) % this.bufferSize === 0) {
                    this.preloadFrames(frameIndex + 1);
                }
            }

            async preloadFrames(startIndex) {
                const endIndex = Math.min(
                    startIndex + this.bufferSize,
                    this.videoInfo.num_frames
                );

                try {
                    const res = await fetch(`/api/video/frames?start=${startIndex}&end=${endIndex}`);
                    const data = await res.json();

                    data.frames.forEach(frame => {
                        this.frameBuffer.set(frame.frame_index, frame);
                    });
                } catch (err) {
                    console.error('Failed to preload frames:', err);
                }
            }

            /**
             * Convert backend pose data to Three.js Matrix4 (camera-to-world).
             *
             * **IMPORTANT:** Backend always provides c2w (camera-to-world) matrices, never w2c.
             * No inversion is needed - just handle the row/column-major format conversion.
             *
             * @param {Array|THREE.Matrix4} pose - Camera-to-world pose data from backend
             * @param {Object} options - Conversion options
             * @param {boolean} options.logRaw - Log raw pose for debugging
             * @param {number} options.frameIndex - Frame index for debug logging
             * @param {boolean} options.alreadyColumnMajor - If true, pose is already in column-major format
             * @returns {THREE.Matrix4|null} Camera-to-world transformation matrix
             *
             * **Implementation Details:**
             * - Backend provides "camera_pose_col_major_flat" (optimal): c2w in column-major, ready for Three.js
             * - Backend provides "camera_pose" (fallback): c2w in row-major, needs transpose
             * - No inversion is performed - backend already inverted w2c to c2w
             */
            poseToMatrix(pose, options = {}) {
                if (!pose) return null;
                const {
                    logRaw = false,
                    frameIndex = null,
                    alreadyColumnMajor = false
                } = options;

                // If already a Matrix4, clone and return
                if (pose instanceof THREE.Matrix4) {
                    return pose.clone();
                }

                // Flatten array if nested
                const flat = pose.flat ? pose.flat() : [].concat(...pose);

                // Pad 3x4 matrices to 4x4
                const normalizedFlat = flat.length === 12 ? [...flat, 0, 0, 0, 1] : flat;

                // Debug logging (only once)
                if (logRaw && !this.rawPoseLogged) {
                    console.group(`🎥 Pose Debug (Frame ${frameIndex ?? 'n/a'})`);
                    console.log('Raw pose from backend:', JSON.stringify(pose));
                    console.log('Flattened (16 elements):', normalizedFlat);
                    console.log('Already column-major?', alreadyColumnMajor);

                    // Show both interpretations
                    const rowMajorPos = [normalizedFlat[3], normalizedFlat[7], normalizedFlat[11]];
                    const colMajorPos = [normalizedFlat[12], normalizedFlat[13], normalizedFlat[14]];
                    console.log('Position if row-major (indices 3,7,11):', rowMajorPos);
                    console.log('Position if col-major (indices 12,13,14):', colMajorPos);
                    console.groupEnd();
                    this.rawPoseLogged = true;
                }

                // Create Three.js matrix
                const m = new THREE.Matrix4();
                m.fromArray(normalizedFlat);

                // If not already column-major, transpose to convert row-major to column-major
                if (!alreadyColumnMajor) {
                    m.transpose();
                }

                return m;
            }

            extractPositionFromPose(pose) {
                if (!pose) return new THREE.Vector3(0, 0, 0);
                const flat = pose.flat ? pose.flat() : [].concat(...pose);
                const normalizedFlat = flat.length === 12 ? [...flat, 0, 0, 0, 1] : flat;
                const rowTranslation = [normalizedFlat[3] || 0, normalizedFlat[7] || 0, normalizedFlat[11] || 0];
                const colTranslation = [normalizedFlat[12] || 0, normalizedFlat[13] || 0, normalizedFlat[14] || 0];
                const rowMag = Math.abs(rowTranslation[0]) + Math.abs(rowTranslation[1]) + Math.abs(rowTranslation[2]);
                const colMag = Math.abs(colTranslation[0]) + Math.abs(colTranslation[1]) + Math.abs(colTranslation[2]);
                const t = (colMag > rowMag) ? colTranslation : rowTranslation;
                return new THREE.Vector3(t[0], t[1], t[2]);
            }

            /**
             * Load and parse camera path data from backend.
             *
             * **Backend API Contract:**
             * - poses_col_major_flat: c2w matrices, column-major flat (preferred, ready for Three.js)
             * - c2w_poses: c2w matrices, row-major nested (fallback, requires transpose)
             * - positions: Camera positions extracted from c2w[:3, 3] (most reliable)
             *
             * **Returns:**
             * - c2w_matrices: Array of THREE.Matrix4 (camera-to-world transformations)
             * - positions: Array of [x, y, z] camera positions
             * - cameraSpline: CatmullRomCurve3 for smooth path interpolation
             */
            async ensureCameraPathData() {
                if (this.cameraPathData) {
                    return this.cameraPathData;
                }

                try {
                    const res = await fetch('/api/video/camera_path');
                    const raw = await res.json();

                    console.log('📡 Loaded camera path data:', {
                        num_frames: raw.num_frames,
                        has_col_major: !!(raw.poses_col_major_flat || raw.c2w_poses_col_major_flat),
                        has_positions: !!(raw.positions && raw.positions.length)
                    });

                    // Prefer column-major flat format (already correct for Three.js)
                    const colMajorFlat = raw.poses_col_major_flat || raw.c2w_poses_col_major_flat || [];
                    const rowMajorNested = raw.c2w_poses || [];

                    // Convert poses to Matrix4
                    let poseMats = [];
                    if (colMajorFlat.length > 0) {
                        // Use pre-transposed column-major data (optimal path)
                        poseMats = colMajorFlat.map((p, idx) => this.poseToMatrix(p, {
                            logRaw: POSE_DEBUG_CONFIG.logFirstRawPose && !this.rawPoseLogged && idx === POSE_DEBUG_CONFIG.rawPoseFrameIndex,
                            frameIndex: idx,
                            alreadyColumnMajor: true  // No transpose needed
                        }));
                        console.log('✅ Using optimized column-major poses');
                    } else if (rowMajorNested.length > 0) {
                        // Fallback: row-major c2w_poses (requires transpose)
                        poseMats = rowMajorNested.map((p, idx) => this.poseToMatrix(p, {
                            logRaw: POSE_DEBUG_CONFIG.logFirstRawPose && !this.rawPoseLogged && idx === POSE_DEBUG_CONFIG.rawPoseFrameIndex,
                            frameIndex: idx,
                            alreadyColumnMajor: false  // Needs transpose
                        }));
                        console.log('⚠️ Using row-major poses (slower, requires transpose)');
                    }

                    poseMats = poseMats.filter(Boolean).map(m => this.applyOrientationToMatrix(m));

                    // Extract camera positions
                    let positions = [];

                    // Method 1: Use backend-provided positions (most reliable)
                    if (raw.positions && raw.positions.length > 0) {
                        // Keep positions exactly as provided; only orientation flips are applied separately.
                        positions = raw.positions.map(pos => new THREE.Vector3(...pos));
                        console.log('✅ Using backend-provided positions');
                    }
                    // Method 2: Extract from c2w matrices
                    else if (poseMats.length > 0) {
                        positions = poseMats.map(m => {
                            const v = new THREE.Vector3();
                            v.setFromMatrixPosition(m);
                            return v;
                        });
                        console.log('ℹ️ Extracted positions from matrices');
                    }

                    if (positions.length === 0) {
                        console.error('❌ No valid camera poses found');
                        return null;
                    }

                    // Validate positions
                    const allAtOrigin = positions.length > 0 && positions.every(p => p.length() < 0.001);
                    if (allAtOrigin) {
                        console.error('❌ All camera positions are at origin! Check pose inversion.');
                    } else if (positions.length > 0) {
                        console.log(`📍 Camera positions: ${positions.length} frames, range: ${
                            Math.min(...positions.map(p => p.length())).toFixed(2)} - ${
                            Math.max(...positions.map(p => p.length())).toFixed(2)} units from origin`);
                    }

                    // Build smooth spline for path interpolation
                    if (positions.length >= 2) {
                        this.cameraSpline = new THREE.CatmullRomCurve3(positions);
                        this.cameraSpline.curveType = 'catmullrom';
                        console.log('✅ Created smooth camera path spline');
                    }

                    // Store processed data
                    this.cameraPathData = {
                        ...raw,
                        positions: positions.map(p => [p.x, p.y, p.z]),
                        c2w_poses: poseMats.map(m => m.toArray()),
                        c2w_matrices: poseMats
                    };

                    return this.cameraPathData;
                } catch (err) {
                    console.error('❌ Failed to load camera path data:', err);
                    return null;
                }
            }

            updatePointCloud(vertices, colors, cameraPose = null) {
                if (!scene) return;

                // Remove old point cloud
                if (this.pointCloudMesh) {
                    scene.remove(this.pointCloudMesh);
                    if (this.pointCloudMesh.geometry) this.pointCloudMesh.geometry.dispose();
                    if (this.pointCloudMesh.material) this.pointCloudMesh.material.dispose();
                }

                // Create new point cloud
                let positions = new Float32Array(vertices.flat());
                const colorsArray = new Float32Array(colors.flat().map(c => c / 255));

                // If camera pose is provided, transform point cloud from camera space to world space
                // cameraPose is null for video frames (already in world space)
                if (cameraPose && positions.length > 0) {
                    positions = this.transformPointsToWorldSpace(positions, cameraPose);
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.015,
                    vertexColors: true,
                    sizeAttenuation: true
                });

                this.pointCloudMesh = new THREE.Points(geometry, material);
                this.pointCloudMesh.renderOrder = 1;
                scene.add(this.pointCloudMesh);

                this.syncCloudVisibility();
            }

            /**
             * Transform point cloud from camera space to world space.
             *
             * **IMPORTANT:** As of the latest backend changes, vertices are already in world space.
             * This function is only called for legacy compatibility or non-video point clouds.
             * For video frames, vertices are pre-transformed in the backend and cameraPose is null.
             *
             * **Critical Understanding (when used):**
             * - If vertices ARE in camera space (rare), cameraPose should be c2w (camera-to-world)
             * - To place points in world space: P_world = c2w * P_camera
             * - No inversion needed if cameraPose is already c2w
             *
             * @param {Float32Array} positions - Point positions [x,y,z,x,y,z,...]
             * @param {Array|THREE.Matrix4|null} cameraPose - Camera-to-world matrix, or null if already world-space
             * @returns {Float32Array} Transformed positions in world space
             */
            transformPointsToWorldSpace(positions, cameraPose) {
                // If no camera pose, points are already in world space (typical for video frames)
                if (!cameraPose) {
                    return positions;
                }

                // Parse camera pose (c2w: camera-to-world)
                let c2w;
                if (cameraPose instanceof THREE.Matrix4) {
                    c2w = cameraPose.clone();
                } else {
                    const flat = cameraPose.flat ? cameraPose.flat() : [].concat(...cameraPose);
                    const normalized = flat.length === 12 ? [...flat, 0, 0, 0, 1] : flat;
                    c2w = new THREE.Matrix4().fromArray(normalized);
                    // Note: Backend sends row-major c2w, so transpose for Three.js
                    c2w.transpose();
                }

                // Debug: Log first transformation
                if (!this.loggedFirstTransform) {
                    console.group('🔄 First Point Cloud Transform');
                    console.log('Camera-to-world (c2w) position:', new THREE.Vector3().setFromMatrixPosition(c2w).toArray());

                    // Test point: 1 meter forward in camera space (0, 0, -1 in OpenGL/Three.js camera coords)
                    const testPoint = new THREE.Vector3(0, 0, -1);
                    const worldPoint = testPoint.applyMatrix4(c2w);
                    console.log('Test: camera(0,0,-1) → world:', worldPoint.toArray().map(v => v.toFixed(2)));
                    console.groupEnd();
                    this.loggedFirstTransform = true;
                }

                // Transform all points from camera space to world space
                const numPoints = positions.length / 3;
                const transformedPositions = new Float32Array(positions.length);
                const point = new THREE.Vector3();

                for (let i = 0; i < numPoints; i++) {
                    const idx = i * 3;
                    point.set(positions[idx], positions[idx + 1], positions[idx + 2]);
                    point.applyMatrix4(c2w);
                    transformedPositions[idx] = point.x;
                    transformedPositions[idx + 1] = point.y;
                    transformedPositions[idx + 2] = point.z;
                }

                return transformedPositions;
            }

            getOrientationScale() {
                // Per-axis flips apply to point vertices only; poses/path positions stay in place.
                return {
                    x: this.signFlip.x ?? 1,
                    y: this.signFlip.y ?? 1,
                    z: this.signFlip.z ?? 1
                };
            }

            applyOrientationToVertices(vertices) {
                const { x, y, z } = this.getOrientationScale();
                if (x === 1 && y === 1 && z === 1) return vertices;
                return vertices.map(v => [
                    v[0] * x,
                    v[1] * y,
                    v[2] * z
                ]);
            }

            getOrientationQuaternion() {
                const yaw180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
                const pitch180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI);
                const roll180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI);
                const q = new THREE.Quaternion();
                if (this.orientationFlips.yaw)   q.premultiply(yaw180);
                if (this.orientationFlips.pitch) q.premultiply(pitch180);
                if (this.orientationFlips.roll)  q.premultiply(roll180);
                return q;
            }

            applyOrientationToMatrix(matrix) {
                if (!matrix) return matrix;

                // Decompose to isolate rotation; keep translation untouched.
                const pos = new THREE.Vector3();
                const quat = new THREE.Quaternion();
                const scl = new THREE.Vector3();
                matrix.decompose(pos, quat, scl);

                // Apply orientation-only flips (no translation change)
                const orientQuat = this.getOrientationQuaternion();
                if (!orientQuat.equals(new THREE.Quaternion())) {
                    quat.premultiply(orientQuat);
                }

                const result = new THREE.Matrix4();
                result.compose(pos, quat, scl);
                return result;
            }

            /**
             * Re-orient world-space points to match a corrected camera pose.
             *
             * Points were transformed by backend using originalC2w.
             * We want them oriented as if they were transformed using correctedC2w.
             *
             * Strategy:
             * 1. Extract rotation difference: R_diff = R_corrected * R_original^-1
             * 2. For each point: rotate around camera position by R_diff
             *
             * @param {Array} vertices - Original vertices [[x,y,z], ...]
             * @param {THREE.Matrix4} originalC2w - Original camera-to-world matrix
             * @param {THREE.Matrix4} correctedC2w - Orientation-corrected c2w matrix
             * @returns {Array} Re-oriented vertices
             */
            reorientPointsForCorrectedPose(vertices, originalC2w, correctedC2w) {
                // Extract camera position (same in both matrices - only rotation changes)
                const camPos = new THREE.Vector3();
                camPos.setFromMatrixPosition(correctedC2w);

                // Extract rotations
                const origQuat = new THREE.Quaternion();
                const corrQuat = new THREE.Quaternion();
                const tempPos = new THREE.Vector3();
                const tempScale = new THREE.Vector3();

                originalC2w.decompose(tempPos, origQuat, tempScale);
                correctedC2w.decompose(tempPos, corrQuat, tempScale);

                // Compute rotation difference: R_diff = R_corrected * R_original^-1
                const origQuatInv = origQuat.clone().invert();
                const rotDiff = corrQuat.clone().multiply(origQuatInv);

                // Re-orient each point around camera position
                const reoriented = vertices.map(v => {
                    const point = new THREE.Vector3(v[0], v[1], v[2]);

                    // Translate to camera-local space
                    point.sub(camPos);

                    // Apply rotation difference
                    point.applyQuaternion(rotDiff);

                    // Translate back to world space
                    point.add(camPos);

                    return [point.x, point.y, point.z];
                });

                return reoriented;
            }

            toggleSignFlip(axis) {
                if (!['x', 'y', 'z'].includes(axis)) return;
                this.signFlip[axis] = (this.signFlip[axis] || 1) * -1;
                try { localStorage.setItem('da3_sign_flips', JSON.stringify(this.signFlip)); } catch (_) {}
                this.onOrientationChanged();
            }

            toggleOrientationFlip(axis) {
                if (!['yaw', 'pitch', 'roll'].includes(axis)) return;
                this.orientationFlips[axis] = !this.orientationFlips[axis];
                try { localStorage.setItem('da3_orientation_flips', JSON.stringify(this.orientationFlips)); } catch (_) {}
                this.onOrientationChanged();
            }

            onOrientationChanged() {
                // Clear cached path so we recompute with new transforms
                this.cameraPathData = null;
                // Reload current frame and path visuals
                if (this.currentFrame != null) {
                    this.loadFrame(this.currentFrame);
                }
                if (this.showCameraPath) {
                    this.loadAndDisplayCameraPath();
                }
                updateSignFlipButtons();
            }

            // ========== SCENE-WIDE TRANSFORMATION ==========
            // Transform entire reconstruction (camera path + point clouds) as a rigid body

            setSceneTranslation(axis, value) {
                if (!['x', 'y', 'z'].includes(axis)) return;
                this.sceneTransform.translation[axis] = value;
                this.applySceneTransform();
            }

            setSceneRotation(id, degrees) {
                if (!['yaw', 'pitch', 'roll'].includes(id)) return;
                this.sceneTransform.rotation[id] = degrees;
                this.applySceneTransform();
            }

            resetSceneTransform() {
                this.sceneTransform = {
                    translation: { x: 0, y: 0, z: 0 },
                    rotation: { yaw: 0, pitch: 0, roll: 0 }
                };
                this.applySceneTransform();
            }

            getSceneTransformMatrix() {
                const { translation, rotation } = this.sceneTransform;

                // Create translation matrix
                const T = new THREE.Matrix4().makeTranslation(
                    translation.x,
                    translation.y,
                    translation.z
                );

                // Create rotation matrices (in degrees, convert to radians)
                const yawRad = THREE.MathUtils.degToRad(rotation.yaw);
                const pitchRad = THREE.MathUtils.degToRad(rotation.pitch);
                const rollRad = THREE.MathUtils.degToRad(rotation.roll);

                const Ry = new THREE.Matrix4().makeRotationY(yawRad);    // Yaw around Y
                const Rx = new THREE.Matrix4().makeRotationX(pitchRad);  // Pitch around X
                const Rz = new THREE.Matrix4().makeRotationZ(rollRad);   // Roll around Z

                // Combine: T * Ry * Rx * Rz (rotate first, then translate)
                const transform = new THREE.Matrix4();
                transform.multiply(T).multiply(Ry).multiply(Rx).multiply(Rz);

                return transform;
            }

            applySceneTransform() {
                const transform = this.getSceneTransformMatrix();

                // Apply to camera path line (includes tube, markers, frustums)
                if (this.cameraPathLine) {
                    this.cameraPathLine.matrix.copy(transform);
                    this.cameraPathLine.matrixAutoUpdate = false;
                }

                // Apply to all camera frustums
                if (this.cameraFrustums) {
                    this.cameraFrustums.forEach(frustum => {
                        if (frustum.userData && frustum.userData.originalMatrix) {
                            // Restore original, then apply scene transform
                            frustum.matrix.copy(frustum.userData.originalMatrix).premultiply(transform);
                        } else {
                            // First time: store original matrix
                            frustum.userData.originalMatrix = frustum.matrix.clone();
                            frustum.matrix.premultiply(transform);
                        }
                        frustum.matrixAutoUpdate = false;
                    });
                }

                // Apply to camera origin markers
                if (this.cameraOrigins) {
                    this.cameraOrigins.forEach(marker => {
                        if (marker.userData && marker.userData.originalPosition) {
                            const pos = marker.userData.originalPosition.clone();
                            pos.applyMatrix4(transform);
                            marker.position.copy(pos);
                        } else {
                            marker.userData.originalPosition = marker.position.clone();
                            const pos = marker.position.clone();
                            pos.applyMatrix4(transform);
                            marker.position.copy(pos);
                        }
                    });
                }

                // Apply to current point cloud
                if (this.pointCloudMesh) {
                    this.pointCloudMesh.matrix.copy(transform);
                    this.pointCloudMesh.matrixAutoUpdate = false;
                }

                // Apply to combined point cloud (video mode)
                if (this.combinedPointCloudMesh) {
                    this.combinedPointCloudMesh.matrix.copy(transform);
                    this.combinedPointCloudMesh.matrixAutoUpdate = false;
                }

                // Apply to global point cloud (single image mode)
                if (typeof pointCloud !== 'undefined' && pointCloud) {
                    pointCloud.matrix.copy(transform);
                    pointCloud.matrixAutoUpdate = false;
                }

                // Apply to current camera helper
                if (this.currentCameraHelper) {
                    if (this.currentCameraHelper.userData && this.currentCameraHelper.userData.originalMatrix) {
                        this.currentCameraHelper.matrix.copy(this.currentCameraHelper.userData.originalMatrix).premultiply(transform);
                    } else {
                        this.currentCameraHelper.userData.originalMatrix = this.currentCameraHelper.matrix.clone();
                        this.currentCameraHelper.matrix.premultiply(transform);
                    }
                    this.currentCameraHelper.matrixAutoUpdate = false;
                }

                console.log('🌐 Scene transform applied:', {
                    translation: this.sceneTransform.translation,
                    rotation: this.sceneTransform.rotation
                });
            }

            loadSignFlip() {
                try {
                    const stored = localStorage.getItem('da3_sign_flips');
                    if (stored) {
                        const parsed = JSON.parse(stored);
                        return {
                            x: parsed.x === -1 ? -1 : 1,
                            y: parsed.y === -1 ? -1 : 1,
                            z: parsed.z === -1 ? -1 : 1,
                        };
                    }
                } catch (_) {}
                return { x: 1, y: 1, z: 1 };
            }

            loadOrientationFlips() {
                try {
                    const stored = localStorage.getItem('da3_orientation_flips');
                    if (stored) {
                        const parsed = JSON.parse(stored);
                        return {
                            yaw: !!parsed.yaw,
                            pitch: !!parsed.pitch,
                            roll: !!parsed.roll,
                        };
                    }
                } catch (_) {}
                // All defaults off - coordinate systems are now properly aligned in backend
                return { yaw: false, pitch: false, roll: false };
            }

            updateFrameCounter() {
                const counter = document.getElementById('frame-counter');
                if (counter && this.videoInfo) {
                    counter.textContent = `${this.currentFrame + 1} / ${this.videoInfo.num_frames}`;
                }
            }

            async play() {
                if (!this.videoInfo || this.isPlaying) return;

                this.isPlaying = true;
                const frameDelay = 1000 / this.videoInfo.fps;

                const playFrame = async () => {
                    if (!this.isPlaying) return;

                    await this.loadFrame(this.currentFrame);

                    // Advance to next frame
                    this.currentFrame++;
                    if (this.currentFrame >= this.videoInfo.num_frames) {
                        if (this.isLooping) {
                            this.currentFrame = 0;
                        } else {
                            this.pause();
                            return;
                        }
                    }

                    this.playbackTimer = setTimeout(playFrame, frameDelay);
                };

                playFrame();
                console.log('Video playback started');
            }

            pause() {
                this.isPlaying = false;
                if (this.playbackTimer) {
                    clearTimeout(this.playbackTimer);
                    this.playbackTimer = null;
                }
                console.log('Video playback paused');
            }

            stop() {
                this.pause();
                this.currentFrame = 0;
                if (this.videoInfo) {
                    this.loadFrame(0);
                }
                console.log('Video playback stopped');
            }

            seekToFrame(frameIndex) {
                const wasPlaying = this.isPlaying;
                this.pause();
                this.loadFrame(frameIndex);
                if (wasPlaying) {
                    this.play();
                }
            }

            toggleLoop() {
                this.isLooping = !this.isLooping;
                const btn = document.getElementById('video-loop-btn');
                if (btn) {
                    btn.style.background = this.isLooping
                        ? 'rgba(16, 185, 129, 0.4)'
                        : 'rgba(16, 185, 129, 0.2)';
                }
                console.log('Loop:', this.isLooping ? 'ON' : 'OFF');
            }

            async toggleCameraPath(forceState = null) {
                if (typeof forceState === 'boolean') {
                    this.showCameraPath = forceState;
                } else {
                    this.showCameraPath = !this.showCameraPath;
                }

                this.setToggleState('video-camera-path-btn', this.showCameraPath);

                if (this.showCameraPath) {
                    await this.loadAndDisplayCameraPath();
                } else {
                    this.clearCameraPath();
                }
            }

            /**
             * Load and display the camera path with smooth spline interpolation.
             *
             * **Visualization Elements:**
             * 1. **Smooth Spline Curve**: Catmull-Rom interpolation through camera positions
             * 2. **Path Tube**: Optional 3D tube geometry following the spline
             * 3. **Directional Gradient**: Color gradient from start (cyan) to end (magenta)
             * 4. **Camera Frustums**: Wireframe pyramids at each frame position
             * 5. **Position Markers**: Spheres at keyframe positions
             * 6. **Motion Indicators**: Velocity-based coloring along the path
             */
            async loadAndDisplayCameraPath() {
                try {
                    const data = await this.ensureCameraPathData();
                    if (!data) return;

                    this.clearCameraPath();

                    // Extract camera positions
                    const keyframePositions = (data.positions || []).map(pos => new THREE.Vector3(...pos));

                    if (keyframePositions.length === 0) {
                        console.error('❌ No camera positions available');
                        return;
                    }

                    console.group('📹 Camera Path Analysis');
                    console.log('Total keyframes:', keyframePositions.length);
                    console.log('First position:',
                        `(${keyframePositions[0].x.toFixed(3)}, ${keyframePositions[0].y.toFixed(3)}, ${keyframePositions[0].z.toFixed(3)})`
                    );
                    if (keyframePositions.length > 1) {
                        console.log('Last position:',
                            `(${keyframePositions[keyframePositions.length-1].x.toFixed(3)}, ${keyframePositions[keyframePositions.length-1].y.toFixed(3)}, ${keyframePositions[keyframePositions.length-1].z.toFixed(3)})`
                        );

                        // Show several intermediate positions
                        const sampleIndices = [
                            Math.floor(keyframePositions.length * 0.25),
                            Math.floor(keyframePositions.length * 0.5),
                            Math.floor(keyframePositions.length * 0.75)
                        ];
                        console.log('Sample positions (25%, 50%, 75%):');
                        sampleIndices.forEach((idx, i) => {
                            const pos = keyframePositions[idx];
                            console.log(`  [${idx}]: (${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)})`);
                        });

                        // Calculate path statistics
                        const distances = [];
                        for (let i = 1; i < keyframePositions.length; i++) {
                            const dist = keyframePositions[i].distanceTo(keyframePositions[i-1]);
                            distances.push(dist);
                        }
                        const totalDistance = distances.reduce((a, b) => a + b, 0);
                        const avgStepDistance = totalDistance / distances.length;

                        console.log(`Path length: ${totalDistance.toFixed(2)} meters (assuming 1 unit = 1 meter)`);
                        console.log(`Average step: ${avgStepDistance.toFixed(3)} meters`);
                        console.log(`Direction from start to end:`, (() => {
                            const dir = new THREE.Vector3().subVectors(
                                keyframePositions[keyframePositions.length-1],
                                keyframePositions[0]
                            ).normalize();
                            return `(${dir.x.toFixed(2)}, ${dir.y.toFixed(2)}, ${dir.z.toFixed(2)})`;
                        })());
                    }
                    console.groupEnd();

                    // Validate positions
                    const firstPosDistance = keyframePositions[0].length();
                    if (firstPosDistance > 0.1) {
                        console.warn(`⚠️ First camera position is NOT at origin: ${firstPosDistance.toFixed(3)} units away`);
                        console.log('Note: DA3 normalizes so first frame should be at ~(0,0,0)');
                    }

                    const allAtOrigin = keyframePositions.every(p => p.length() < 0.001);
                    if (allAtOrigin) {
                        console.error('❌ All camera positions are at origin! Check pose inversion.');
                        console.error('⚠️  WARNING: Attempting to visualize anyway - this may show nothing or unexpected results');
                        // DON'T return early - let the visualization attempt to render
                        // This helps debug what's actually being received from backend
                    }

                    // ========== CREATE SMOOTH SPLINE PATH ==========
                    if (!this.cameraSpline || keyframePositions.length < 2) {
                        console.warn('⚠️ Cannot create spline with < 2 points');
                        return;
                    }

                    // Create high-resolution smooth path
                    const numSplineSamples = Math.max(200, keyframePositions.length * 15);
                    const smoothPathPoints = this.cameraSpline.getPoints(numSplineSamples);

                    console.log(`✅ Generated smooth spline: ${keyframePositions.length} keyframes → ${numSplineSamples} smooth points`);

                    // ========== CREATE PATH VISUALIZATION ==========

                    // Option 1: Standard line with gradient coloring
                    const pathGeometry = new THREE.BufferGeometry().setFromPoints(smoothPathPoints);

                    // Create gradient colors from start (cyan) to end (magenta) along path
                    const colors = new Float32Array(smoothPathPoints.length * 3);
                    for (let i = 0; i < smoothPathPoints.length; i++) {
                        const t = i / (smoothPathPoints.length - 1);
                        // Gradient: cyan (0,1,1) → blue (0,0.5,1) → magenta (1,0,1)
                        colors[i * 3 + 0] = t; // R: 0 → 1
                        colors[i * 3 + 1] = 1 - t * 0.5; // G: 1 → 0.5
                        colors[i * 3 + 2] = 1; // B: 1
                    }
                    pathGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                    const pathMaterial = new THREE.LineBasicMaterial({
                        vertexColors: true,
                        linewidth: 3,
                        opacity: 0.9,
                        transparent: true
                    });

                    this.cameraPathLine = new THREE.Line(pathGeometry, pathMaterial);
                    this.cameraPathLine.renderOrder = 999; // Render on top
                    scene.add(this.cameraPathLine);

                    // ========== ADD TUBE GEOMETRY FOR 3D EFFECT (Optional) ==========
                    // Create a tube geometry that follows the spline for a more 3D appearance
                    const tubeGeometry = new THREE.TubeGeometry(
                        this.cameraSpline,
                        numSplineSamples,
                        0.008, // Tube radius
                        8, // Radial segments
                        false // Not closed
                    );

                    // Create gradient material for the tube
                    const tubeColors = new Float32Array(tubeGeometry.attributes.position.count * 3);
                    for (let i = 0; i < tubeGeometry.attributes.position.count; i++) {
                        const t = (i / tubeGeometry.attributes.position.count);
                        tubeColors[i * 3 + 0] = t; // R
                        tubeColors[i * 3 + 1] = 1 - t * 0.5; // G
                        tubeColors[i * 3 + 2] = 1; // B
                    }
                    tubeGeometry.setAttribute('color', new THREE.BufferAttribute(tubeColors, 3));

                    const tubeMaterial = new THREE.MeshBasicMaterial({
                        vertexColors: true,
                        opacity: 0.6,
                        transparent: true,
                        side: THREE.DoubleSide
                    });

                    const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    tubeMesh.renderOrder = 998;
                    this.cameraPathLine.add(tubeMesh); // Add as child so it gets cleared together

                    console.log(`✅ Camera path spline: ${smoothPathPoints.length} smooth points with 3D tube`);

                    // ========== ADD CAMERA FRUSTUMS ==========
                    const poseSource = (data.c2w_matrices && data.c2w_matrices.length)
                        ? data.c2w_matrices
                        : (data.poses_col_major_flat || data.c2w_poses_col_major_flat || data.c2w_poses || data.poses || []);

                    const poses = poseSource
                        .map((p) => p instanceof THREE.Matrix4
                            ? p
                            : this.poseToMatrix(p, {
                                alreadyColumnMajor: !!(data.c2w_matrices && data.c2w_matrices.length) ||
                                    !!(data.poses_col_major_flat || data.c2w_poses_col_major_flat)
                            }))
                        .filter(Boolean);

                    poses.forEach((pose, index) => {
                        const frustum = this.createCameraFrustum(pose, index);
                        this.cameraFrustums.push(frustum);
                        scene.add(frustum);
                    });

                    console.log(`✅ Added ${poses.length} camera frustums`);

                    // ========== ADD KEYFRAME POSITION MARKERS ==========
                    const originGeom = new THREE.SphereGeometry(0.03, 12, 12);
                    const originMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0.7, transparent: true });
                    const activeMat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 1.0, transparent: true });

                    keyframePositions.forEach((pos, idx) => {
                        const mesh = new THREE.Mesh(originGeom, originMat.clone());
                        mesh.position.copy(pos);
                        mesh.userData.frameIndex = idx;
                        mesh.userData.activeMat = activeMat;
                        mesh.userData.baseMat = mesh.material;
                        this.cameraOrigins.push(mesh);
                        scene.add(mesh);
                    });

                    console.log(`✅ Added ${keyframePositions.length} keyframe markers`);

                    // ========== ADD COORDINATE AXES AT FIRST CAMERA FOR REFERENCE ==========
                    // Add axes helper at the first camera position to show the world coordinate system
                    const firstCameraAxes = new THREE.AxesHelper(0.3);
                    firstCameraAxes.position.copy(keyframePositions[0]);
                    this.cameraPathLine.add(firstCameraAxes);
                    console.log('✅ Added coordinate axes at first camera position');

                    // ========== ADD DIRECTION ARROWS ALONG PATH ==========
                    // Add arrows showing camera direction at intervals
                    const arrowInterval = Math.max(1, Math.floor(keyframePositions.length / 10));
                    poses.forEach((pose, idx) => {
                        if (idx % arrowInterval === 0 || idx === poses.length - 1) {
                            const position = new THREE.Vector3();
                            const quaternion = new THREE.Quaternion();
                            const scale = new THREE.Vector3();
                            pose.decompose(position, quaternion, scale);

                            // Camera looks down -Z, so forward direction is negative Z in camera space
                            const forward = new THREE.Vector3(0, 0, -1);
                            forward.applyQuaternion(quaternion).normalize();

                            // Create arrow showing direction
                            const arrowHelper = new THREE.ArrowHelper(
                                forward,
                                position,
                                0.2, // Length
                                idx === 0 ? 0x00ffff : (idx === poses.length - 1 ? 0xff00ff : 0x00ff88), // Cyan for start, magenta for end
                                0.08, // Head length
                                0.06  // Head width
                            );
                            arrowHelper.userData.isDirectionArrow = true;
                            this.cameraPathLine.add(arrowHelper);
                        }
                    });

                    console.log(`✅ Added direction arrows at ${Math.ceil(poses.length / arrowInterval)} positions`);

                    // ========== ADD START/END MARKERS ==========
                    // Special markers for start and end of path
                    if (keyframePositions.length > 0) {
                        // Start marker (larger cyan sphere)
                        const startGeom = new THREE.SphereGeometry(0.05, 16, 16);
                        const startMat = new THREE.MeshBasicMaterial({
                            color: 0x00ffff,
                            opacity: 0.9,
                            transparent: true
                        });
                        const startMarker = new THREE.Mesh(startGeom, startMat);
                        startMarker.position.copy(keyframePositions[0]);
                        this.cameraPathLine.add(startMarker);

                        // End marker (larger magenta sphere)
                        const endGeom = new THREE.SphereGeometry(0.05, 16, 16);
                        const endMat = new THREE.MeshBasicMaterial({
                            color: 0xff00ff,
                            opacity: 0.9,
                            transparent: true
                        });
                        const endMarker = new THREE.Mesh(endGeom, endMat);
                        endMarker.position.copy(keyframePositions[keyframePositions.length - 1]);
                        this.cameraPathLine.add(endMarker);

                        console.log('✅ Added start/end markers (cyan/magenta)');
                    }

                    // ========== ADD COORDINATE AXES AT ORIGIN ==========
                    // Add XYZ axes to show world coordinate system
                    // This helps understand camera path orientation
                    const axesGroup = new THREE.Group();

                    // X axis (Red) - Right
                    const xAxisGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(1, 0, 0)
                    ]);
                    const xAxisMat = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
                    const xAxis = new THREE.Line(xAxisGeom, xAxisMat);
                    axesGroup.add(xAxis);

                    // Add arrow cone at end of X axis
                    const xCone = new THREE.Mesh(
                        new THREE.ConeGeometry(0.02, 0.08, 8),
                        new THREE.MeshBasicMaterial({ color: 0xff0000 })
                    );
                    xCone.position.set(1, 0, 0);
                    xCone.rotation.z = -Math.PI / 2;
                    axesGroup.add(xCone);

                    // Y axis (Green) - Up
                    const yAxisGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, 1, 0)
                    ]);
                    const yAxisMat = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
                    const yAxis = new THREE.Line(yAxisGeom, yAxisMat);
                    axesGroup.add(yAxis);

                    // Add arrow cone at end of Y axis
                    const yCone = new THREE.Mesh(
                        new THREE.ConeGeometry(0.02, 0.08, 8),
                        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                    );
                    yCone.position.set(0, 1, 0);
                    axesGroup.add(yCone);

                    // Z axis (Blue) - Forward (in world space)
                    const zAxisGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, 0, 1)
                    ]);
                    const zAxisMat = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 });
                    const zAxis = new THREE.Line(zAxisGeom, zAxisMat);
                    axesGroup.add(zAxis);

                    // Add arrow cone at end of Z axis
                    const zCone = new THREE.Mesh(
                        new THREE.ConeGeometry(0.02, 0.08, 8),
                        new THREE.MeshBasicMaterial({ color: 0x0000ff })
                    );
                    zCone.position.set(0, 0, 1);
                    zCone.rotation.x = Math.PI / 2;
                    axesGroup.add(zCone);

                    // Add axis labels
                    // Position axes at first camera position (normalized origin)
                    axesGroup.position.copy(keyframePositions[0]);

                    this.cameraPathLine.add(axesGroup);
                    console.log('✅ Added world coordinate axes at origin (X=Red, Y=Green, Z=Blue)');

                    // ========== ADD REFERENCE GRID ==========
                    // Add a grid on the XZ plane to show scale (1 unit = 1 meter)
                    const gridSize = 10;
                    const gridDivisions = 10;
                    const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x444444, 0x222222);
                    // Position grid at first camera Y position
                    gridHelper.position.y = keyframePositions[0].y;
                    this.cameraPathLine.add(gridHelper);
                    console.log('✅ Added reference grid (10m × 10m, 1m spacing)');

                    // ========== ADD ANIMATED PROGRESS MARKER ==========
                    // Create a glowing sphere that moves along the path during playback
                    const progressGeom = new THREE.SphereGeometry(0.06, 16, 16);
                    const progressMat = new THREE.MeshBasicMaterial({
                        color: 0xffff00,
                        opacity: 1.0,
                        transparent: false
                    });
                    this.pathProgressMarker = new THREE.Mesh(progressGeom, progressMat);
                    this.pathProgressMarker.visible = true;

                    // Add glowing effect
                    const glowGeom = new THREE.SphereGeometry(0.09, 16, 16);
                    const glowMat = new THREE.MeshBasicMaterial({
                        color: 0xffff00,
                        opacity: 0.3,
                        transparent: true
                    });
                    const glowSphere = new THREE.Mesh(glowGeom, glowMat);
                    this.pathProgressMarker.add(glowSphere);

                    // Position at first keyframe
                    if (keyframePositions.length > 0) {
                        this.pathProgressMarker.position.copy(keyframePositions[0]);
                    }

                    scene.add(this.pathProgressMarker);
                    console.log('✅ Added animated progress marker (yellow sphere)');

                    // ========== SUMMARY ==========
                    console.group('📹 Camera Path Visualization Complete');
                    console.log(`• Path Type: Smooth Catmull-Rom Spline`);
                    console.log(`• Keyframes: ${keyframePositions.length}`);
                    console.log(`• Smooth Points: ${smoothPathPoints.length}`);
                    console.log(`• Camera Frustums: ${poses.length}`);
                    console.log(`• Visual Style: Gradient tube with direction arrows`);
                    console.log(`• Color Coding: Cyan (start) → Magenta (end)`);
                    console.log(`• Animated Marker: Yellow glowing sphere tracks playback`);
                    console.groupEnd();
                } catch (err) {
                    console.error('❌ Failed to load camera path:', err);
                }
            }

            /**
             * Create a camera frustum visualization.
             *
             * @param {THREE.Matrix4|Array} poseMatrix - Camera-to-world transformation
             * @param {number} index - Frame index
             * @param {Object} options - Options (color, frameData)
             * @returns {THREE.Group} Frustum visualization group
             *
             * **Frustum Geometry:**
             * - Defined in camera space: origin at (0,0,0), looking down -Z
             * - Far plane is a rectangle at distance `far` in front of camera
             * - Dimensions calculated from FOV and aspect ratio (from intrinsics)
             * - Transformed to world space using c2w matrix
             */
            createCameraFrustum(poseMatrix, index, options = {}) {
                // Get intrinsics for this frame if available
                const frame = options.frameData || this.frameBuffer.get(index);
                let fov = 60; // default FOV in degrees
                let aspect = 16 / 9; // default aspect ratio

                if (frame && frame.intrinsics) {
                    // Compute FOV from intrinsics
                    const fx = frame.intrinsics[0][0];
                    const fy = frame.intrinsics[1][1];
                    const cx = frame.intrinsics[0][2];
                    const cy = frame.intrinsics[1][2];

                    // Image dimensions (use actual values if available, else approximate from principal point)
                    const imageWidth = frame.image_width || (cx * 2);
                    const imageHeight = frame.image_height || (cy * 2);

                    // Compute vertical FOV
                    const fovRadians = 2 * Math.atan(imageHeight / (2 * fy));
                    fov = THREE.MathUtils.radToDeg(fovRadians);
                    aspect = imageWidth / imageHeight;
                }

                // Create frustum geometry based on actual camera parameters
                const frustumSize = 0.15; // Scale for visibility
                const near = 0.01;
                const far = frustumSize;

                // Calculate frustum dimensions at far plane
                const halfHeight = far * Math.tan(THREE.MathUtils.degToRad(fov) / 2);
                const halfWidth = halfHeight * aspect;

                // Define frustum vertices in camera space
                // Camera looks down -Z axis (Three.js/OpenGL convention)
                const vertices = [
                    new THREE.Vector3(0, 0, 0),                           // 0: Camera origin
                    new THREE.Vector3(-halfWidth, halfHeight, -far),      // 1: Top-left far
                    new THREE.Vector3(halfWidth, halfHeight, -far),       // 2: Top-right far
                    new THREE.Vector3(halfWidth, -halfHeight, -far),      // 3: Bottom-right far
                    new THREE.Vector3(-halfWidth, -halfHeight, -far)      // 4: Bottom-left far
                ];

                // Create edges connecting frustum vertices
                const edges = [
                    // Lines from origin to far corners
                    [0, 1], [0, 2], [0, 3], [0, 4],
                    // Far plane rectangle
                    [1, 2], [2, 3], [3, 4], [4, 1]
                ];

                const frustumLines = new THREE.Group();
                const lineColor = options.color || 0x00ff00;
                edges.forEach(([start, end]) => {
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        vertices[start],
                        vertices[end]
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: lineColor,
                        opacity: 0.6,
                        transparent: true
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    frustumLines.add(line);
                });

                // Apply camera-to-world transformation
                // poseMatrix should be c2w (camera space → world space)
                const matrix = new THREE.Matrix4();
                if (poseMatrix instanceof THREE.Matrix4) {
                    matrix.copy(poseMatrix);
                } else {
                    const flatMatrix = poseMatrix.flat ? poseMatrix.flat() : [].concat(...poseMatrix);
                    matrix.fromArray(flatMatrix);
                    // Note: If this is from backend and not already transposed, may need transpose here
                    // But our ensureCameraPathData() already handles this, providing c2w matrices
                }

                frustumLines.applyMatrix4(matrix);

                frustumLines.userData.frameIndex = index;
                frustumLines.userData.isFrustum = true;
                frustumLines.matrixAutoUpdate = false;

                return frustumLines;
            }

            /**
             * Clear all camera path visualization elements from the scene.
             */
            clearCameraPath() {
                // Remove main path line (includes tube and children)
                if (this.cameraPathLine) {
                    scene.remove(this.cameraPathLine);
                    // Dispose of all children recursively
                    this.cameraPathLine.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose && m.dispose());
                            } else if (child.material.dispose) {
                                child.material.dispose();
                            }
                        }
                    });
                    this.cameraPathLine = null;
                }

                // Remove camera frustums
                this.cameraFrustums.forEach(frustum => {
                    this.disposeFrustum(frustum);
                });
                this.cameraFrustums = [];

                // Remove keyframe position markers
                this.cameraOrigins.forEach(origin => {
                    scene.remove(origin);
                    if (origin.geometry) origin.geometry.dispose();
                    if (origin.material && origin.material.dispose) origin.material.dispose();
                });
                this.cameraOrigins = [];

                // Remove progress marker
                if (this.pathProgressMarker) {
                    scene.remove(this.pathProgressMarker);
                    this.pathProgressMarker.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material && child.material.dispose) child.material.dispose();
                    });
                    this.pathProgressMarker = null;
                }
            }

            disposeFrustum(obj) {
                if (!obj) return;
                scene.remove(obj);
                obj.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose && m.dispose());
                        } else if (child.material.dispose) {
                            child.material.dispose();
                        }
                    }
                });
            }

            updateCameraHelper(frame) {
                if (!frame) return;
                const c2wMat = frame._c2w_matrix
                    || (frame._c2w ? this.poseToMatrix(frame._c2w, { alreadyColumnMajor: true }) : null)
                    || this.poseToMatrix(frame.camera_pose_col_major_flat || frame.camera_pose, { alreadyColumnMajor: !!frame.camera_pose_col_major_flat });
                if (!c2wMat) return;
                const poseForHelper = c2wMat;
                const helper = this.createCameraFrustum(
                    poseForHelper,
                    frame.frame_index ?? this.currentFrame,
                    { color: 0xffff00, frameData: frame }
                );

                if (this.currentCameraHelper) {
                    this.disposeFrustum(this.currentCameraHelper);
                }
                this.currentCameraHelper = helper;
                scene.add(helper);
            }

            // ========== NEW CAMERA FOLLOWING FEATURES ==========

            toggleFrameOnly() {
                this.showFrameOnly = !this.showFrameOnly;
                this.syncCloudVisibility();
                console.log('Frame-only view:', this.showFrameOnly ? 'ON' : 'OFF');
            }

            toggleAttachToPath() {
                this.followCamera = !this.followCamera;
                this.setToggleState('video-follow-cam-btn', this.followCamera);

                if (this.followCamera) {
                    // Save current camera state
                    this.previousCameraState = {
                        position: camera.position.clone(),
                        rotation: camera.rotation.clone()
                    };

                    // Disable orbit/fly controls when following
                    if (typeof orbitControls !== 'undefined' && orbitControls) {
                        orbitControls.enabled = false;
                    }
                    if (typeof flyControls !== 'undefined' && flyControls) {
                        flyControls.enabled = false;
                    }

                    // Ensure camera path and helpers are visible
                    this.toggleCameraPath(true);

                    // Apply current frame's camera
                    const frame = this.frameBuffer.get(this.currentFrame);
                    if (frame && frame.intrinsics) {
                        const pose = frame._c2w_matrix || this.poseToMatrix(frame.camera_pose, {
                            logRaw: POSE_DEBUG_CONFIG.logFirstRawPose && !this.rawPoseLogged && this.currentFrame === POSE_DEBUG_CONFIG.rawPoseFrameIndex,
                            frameIndex: frame.frame_index ?? this.currentFrame
                        });
                        if (pose) {
                            this.updateViewerCamera(pose, frame.intrinsics, { frameIndex: frame.frame_index ?? this.currentFrame });
                        }
                    }

                    console.log('Camera attached to path');
                } else {
                    // Restore previous camera state
                    if (this.previousCameraState) {
                        camera.position.copy(this.previousCameraState.position);
                        camera.rotation.copy(this.previousCameraState.rotation);
                    }

                    // Re-enable controls
                    const controlMode = localStorage.getItem('controlMode') || 'orbit';
                    if (controlMode === 'orbit' && typeof orbitControls !== 'undefined' && orbitControls) {
                        orbitControls.enabled = true;
                    } else if (controlMode === 'fly' && typeof flyControls !== 'undefined' && flyControls) {
                        flyControls.enabled = true;
                    }

                    console.log('Camera detached from path');
                }
            }

            // Backwards-compat alias
            toggleFollowCamera() {
                return this.toggleAttachToPath();
            }

            async playWalkthrough() {
                if (!this.videoInfo) {
                    const ok = await this.loadVideo();
                    if (!ok) return;
                }
                await this.toggleCameraPath(true);
                this.play();
            }

            updateViewerCamera(cameraPose, intrinsics, options = {}) {
                // cameraPose should be camera-to-world, column-major
                const { frameIndex = null, alreadyColumnMajor = false } = options;

                let poseMatrix = null;
                if (cameraPose instanceof THREE.Matrix4) {
                    poseMatrix = cameraPose.clone();
                } else {
                    const flat = cameraPose?.flat ? cameraPose.flat() : [].concat(...(cameraPose || []));
                    const rowTranslationSum = Math.abs(flat[3] || 0) + Math.abs(flat[7] || 0) + Math.abs(flat[11] || 0);
                    const colTranslationSum = Math.abs(flat[12] || 0) + Math.abs(flat[13] || 0) + Math.abs(flat[14] || 0);
                    const treatAsColumnMajor = alreadyColumnMajor || (colTranslationSum > rowTranslationSum && colTranslationSum !== 0);
                    poseMatrix = this.poseToMatrix(cameraPose, { alreadyColumnMajor: treatAsColumnMajor });
                }
                if (!poseMatrix) return;

                // Extract position and rotation directly (already c2w)
                const position = new THREE.Vector3();
                const quaternion = new THREE.Quaternion();
                const scale = new THREE.Vector3();
                poseMatrix.decompose(position, quaternion, scale);

                this.maybeDebugPose(poseMatrix, position, quaternion, frameIndex);

                // Apply to viewer camera with smooth transition
                if (this.followCamera) {
                    camera.position.lerp(position, 0.3);  // Smooth interpolation
                    camera.quaternion.slerp(quaternion, 0.3);  // Spherical interpolation for rotation
                } else {
                    camera.position.copy(position);
                    camera.quaternion.copy(quaternion);
                }

                // Update camera FOV based on intrinsics (optional)
                if (intrinsics && intrinsics.length >= 3) {
                    // Extract focal length and compute FOV
                    const fy = intrinsics[1][1];  // Vertical focal length
                    const imageHeight = 512;  // Approximate, could be from videoInfo
                    const fovRadians = 2 * Math.atan(imageHeight / (2 * fy));
                    const fovDegrees = THREE.MathUtils.radToDeg(fovRadians);

                    // Smoothly adjust FOV
                    camera.fov = THREE.MathUtils.lerp(camera.fov, fovDegrees, 0.2);
                    camera.updateProjectionMatrix();
                }
            }

            maybeDebugPose(poseMatrix, position, quaternion, frameIndex = null) {
                if (!POSE_DEBUG_CONFIG.enabled) {
                    this.disposePoseDebugLine();
                    return;
                }

                try {
                    console.log(`[pose-debug] Normalized c2w (column-major, frame ${frameIndex ?? 'n/a'})`, poseMatrix.elements.slice());
                    console.log(`[pose-debug] Position (frame ${frameIndex ?? 'n/a'})`, position.toArray());
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(quaternion).normalize();
                    console.log(`[pose-debug] Forward (-Z camera) (frame ${frameIndex ?? 'n/a'})`, forward.toArray());

                    if (POSE_DEBUG_CONFIG.drawForwardRay && scene) {
                        const start = position.clone();
                        const end = start.clone().add(forward.multiplyScalar(POSE_DEBUG_CONFIG.forwardRayLength || 0.35));
                        const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
                        const material = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9 });
                        const line = new THREE.Line(geometry, material);
                        this.disposePoseDebugLine();
                        scene.add(line);
                        this.poseDebugLine = line;
                    } else {
                        this.disposePoseDebugLine();
                    }
                    this.lastPoseDebugFrame = frameIndex;
                } catch (err) {
                    console.warn('Pose debug logging failed:', err);
                }
            }

            disposePoseDebugLine() {
                if (this.poseDebugLine) {
                    if (scene) {
                        scene.remove(this.poseDebugLine);
                    }
                    if (this.poseDebugLine.geometry) this.poseDebugLine.geometry.dispose();
                    if (this.poseDebugLine.material && this.poseDebugLine.material.dispose) {
                        this.poseDebugLine.material.dispose();
                    }
                    this.poseDebugLine = null;
                }
            }

            /**
             * Update the animated progress marker position along the camera path.
             *
             * @param {number} frameIndex - Current frame index
             */
            updatePathProgressMarker(frameIndex) {
                if (!this.pathProgressMarker || !this.cameraPathData) return;

                const positions = this.cameraPathData.positions;
                if (!positions || positions.length === 0) return;

                // Clamp frame index to valid range
                const clampedIndex = Math.min(frameIndex, positions.length - 1);

                // Update marker position
                const pos = positions[clampedIndex];
                this.pathProgressMarker.position.set(pos[0], pos[1], pos[2]);

                // Pulse animation based on playback state
                if (this.isPlaying) {
                    const time = Date.now() * 0.003;
                    const scale = 1.0 + Math.sin(time) * 0.15;
                    this.pathProgressMarker.scale.set(scale, scale, scale);
                } else {
                    this.pathProgressMarker.scale.set(1, 1, 1);
                }

                // Make visible only when path is shown
                this.pathProgressMarker.visible = this.showCameraPath;
            }

            highlightCurrentFrustum(frameIndex) {
                // Reset all frustum colors
                this.cameraFrustums.forEach((frustum, idx) => {
                    const isActive = idx === frameIndex;
                    const color = isActive ? 0xffff00 : 0x00ff00;  // Yellow for active, green for others
                    const opacity = isActive ? 1.0 : 0.6;

                    // Update all line materials in the frustum group
                    if (frustum.userData.isFrustum && frustum.children) {
                        frustum.children.forEach(line => {
                            if (line.material) {
                                line.material.color.setHex(color);
                                line.material.opacity = opacity;
                            }
                        });
                    } else if (frustum.material) {
                        // Fallback for old-style frustums
                        frustum.material.color.setHex(color);
                        frustum.material.opacity = opacity;
                    }
                });

                // Highlight current origin marker
                this.cameraOrigins.forEach((origin, idx) => {
                    const isActive = idx === frameIndex;
                    if (isActive && origin.userData.activeMat) {
                        origin.material = origin.userData.activeMat;
                        origin.scale.set(1.2, 1.2, 1.2);
                    } else if (origin.userData.baseMat) {
                        origin.material = origin.userData.baseMat;
                        origin.scale.set(1, 1, 1);
                    }
                });
            }

            reset() {
                this.stop();
                this.clearCameraPath();
                this.frameBuffer.clear();
                this.videoInfo = null;
                this.showCameraPath = false;
                this.cameraData = null;
                this.cameraPathData = null;
                this.cameraSpline = null;
                this.showFrameOnly = false;
                this.rawPoseLogged = false;
                this.lastPoseDebugFrame = null;
                this.disposePoseDebugLine();

                if (this.currentCameraHelper) {
                    this.disposeFrustum(this.currentCameraHelper);
                    this.currentCameraHelper = null;
                }
                if (this.combinedPointCloudMesh) {
                    this.combinedPointCloudMesh.visible = true;
                }
                this.combinedPointCloudMesh = null;
                this.combinedPointCloudData = null;
                if (this.pointCloudMesh) {
                    scene.remove(this.pointCloudMesh);
                    if (this.pointCloudMesh.geometry) this.pointCloudMesh.geometry.dispose();
                    if (this.pointCloudMesh.material && this.pointCloudMesh.material.dispose) {
                        this.pointCloudMesh.material.dispose();
                    }
                    this.pointCloudMesh = null;
                }

                // Disable camera following and restore controls
                if (this.followCamera) {
                    this.followCamera = false;
                    const controlMode = localStorage.getItem('controlMode') || 'orbit';
                    if (controlMode === 'orbit' && typeof orbitControls !== 'undefined' && orbitControls) {
                        orbitControls.enabled = true;
                    } else if (controlMode === 'fly' && typeof flyControls !== 'undefined' && flyControls) {
                        flyControls.enabled = true;
                    }
                }

                this.setToggleState('video-follow-cam-btn', false);
                this.setToggleState('video-camera-path-btn', false);
                this.setToggleState('video-frame-only-btn', false);

                document.getElementById('video-controls').style.display = 'none';
            }
        }

        // Global video player instance
        const videoPlayer = new VideoPlayer();

        // Sign flip helper UI
        function createSignFlipPanel() {
            const existing = document.getElementById('sign-flip-panel');
            if (existing) existing.remove();

            const panel = document.createElement('div');
            panel.id = 'sign-flip-panel';

            const title = document.createElement('h4');
            title.textContent = 'Sign Flips';
            panel.appendChild(title);

            const row = document.createElement('div');
            row.className = 'flip-buttons';
            ['x', 'y', 'z'].forEach(axis => {
                const btn = document.createElement('button');
                btn.id = `sign-flip-${axis}`;
                btn.textContent = `${axis.toUpperCase()}: +`;
                btn.addEventListener('click', () => videoPlayer.toggleSignFlip(axis));
                row.appendChild(btn);
            });
            panel.appendChild(row);

            const row2 = document.createElement('div');
            row2.className = 'flip-row';
            [
                { id: 'yaw', label: 'Yaw 180°' },
                { id: 'pitch', label: 'Pitch 180°' },
                { id: 'roll', label: 'Roll 180°' },
            ].forEach(({ id, label }) => {
                const btn = document.createElement('button');
                btn.id = `orientation-flip-${id}`;
                btn.textContent = label;
                btn.addEventListener('click', () => videoPlayer.toggleOrientationFlip(id));
                row2.appendChild(btn);
            });
            panel.appendChild(row2);

            const note = document.createElement('div');
            note.style.fontSize = '11px';
            note.style.opacity = '0.75';
            note.textContent = 'Flip axes or yaw to align cloud ↔ path';
            panel.appendChild(note);

            document.body.appendChild(panel);
            updateSignFlipButtons();
        }

        function updateSignFlipButtons() {
            const flips = videoPlayer.getOrientationScale();
            ['x', 'y', 'z'].forEach(axis => {
                const btn = document.getElementById(`sign-flip-${axis}`);
                if (!btn) return;
                const sign = flips[axis] === -1 ? '-' : '+';
                btn.textContent = `${axis.toUpperCase()}: ${sign}`;
                btn.classList.toggle('active', flips[axis] === -1);
            });
            ['yaw', 'pitch', 'roll'].forEach(axis => {
                const btn = document.getElementById(`orientation-flip-${axis}`);
                if (!btn) return;
                btn.classList.toggle('active', !!videoPlayer.orientationFlips[axis]);
            });
        }

        // Scene Alignment Panel - Global transformation for entire reconstruction
        function createSceneAlignmentPanel() {
            const existing = document.getElementById('scene-alignment-panel');
            if (existing) existing.remove();

            const panel = document.createElement('div');
            panel.id = 'scene-alignment-panel';
            panel.style.cssText = `
                position: fixed;
                top: 300px;
                right: 20px;
                background: rgba(0, 0, 0, 0.85);
                color: white;
                padding: 15px;
                border-radius: 8px;
                font-family: monospace;
                font-size: 12px;
                z-index: 1000;
                max-width: 280px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            `;

            const title = document.createElement('h4');
            title.textContent = '🌐 Scene Alignment';
            title.style.margin = '0 0 12px 0';
            title.style.fontSize = '14px';
            title.style.borderBottom = '1px solid #444';
            title.style.paddingBottom = '8px';
            panel.appendChild(title);

            // Translation controls
            const transTitle = document.createElement('div');
            transTitle.textContent = 'Translation (meters)';
            transTitle.style.cssText = 'margin: 10px 0 5px 0; font-size: 11px; opacity: 0.8;';
            panel.appendChild(transTitle);

            ['x', 'y', 'z'].forEach(axis => {
                const row = document.createElement('div');
                row.style.cssText = 'margin: 6px 0; display: flex; align-items: center; gap: 8px;';

                const label = document.createElement('label');
                label.textContent = `${axis.toUpperCase()}:`;
                label.style.cssText = 'width: 20px; font-weight: bold;';
                row.appendChild(label);

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.id = `scene-trans-${axis}`;
                slider.min = '-10';
                slider.max = '10';
                slider.step = '0.1';
                slider.value = '0';
                slider.style.cssText = 'flex: 1;';
                slider.addEventListener('input', (e) => {
                    valueDisplay.textContent = parseFloat(e.target.value).toFixed(1);
                    videoPlayer.setSceneTranslation(axis, parseFloat(e.target.value));
                });
                row.appendChild(slider);

                const valueDisplay = document.createElement('span');
                valueDisplay.textContent = '0.0';
                valueDisplay.style.cssText = 'width: 35px; text-align: right; font-size: 11px;';
                row.appendChild(valueDisplay);

                panel.appendChild(row);
            });

            // Rotation controls
            const rotTitle = document.createElement('div');
            rotTitle.textContent = 'Rotation (degrees)';
            rotTitle.style.cssText = 'margin: 15px 0 5px 0; font-size: 11px; opacity: 0.8;';
            panel.appendChild(rotTitle);

            [
                { id: 'yaw', label: 'Yaw (Y)' },
                { id: 'pitch', label: 'Pitch (X)' },
                { id: 'roll', label: 'Roll (Z)' }
            ].forEach(({ id, label }) => {
                const row = document.createElement('div');
                row.style.cssText = 'margin: 6px 0; display: flex; align-items: center; gap: 8px;';

                const labelEl = document.createElement('label');
                labelEl.textContent = label;
                labelEl.style.cssText = 'width: 65px; font-size: 11px;';
                row.appendChild(labelEl);

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.id = `scene-rot-${id}`;
                slider.min = '-180';
                slider.max = '180';
                slider.step = '1';
                slider.value = '0';
                slider.style.cssText = 'flex: 1;';
                slider.addEventListener('input', (e) => {
                    valueDisplay.textContent = e.target.value + '°';
                    videoPlayer.setSceneRotation(id, parseFloat(e.target.value));
                });
                row.appendChild(slider);

                const valueDisplay = document.createElement('span');
                valueDisplay.textContent = '0°';
                valueDisplay.style.cssText = 'width: 40px; text-align: right; font-size: 11px;';
                row.appendChild(valueDisplay);

                panel.appendChild(row);
            });

            // Reset button
            const resetBtn = document.createElement('button');
            resetBtn.textContent = '↺ Reset All';
            resetBtn.style.cssText = `
                width: 100%;
                margin-top: 12px;
                padding: 8px;
                background: #444;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
            `;
            resetBtn.addEventListener('click', () => {
                ['x', 'y', 'z'].forEach(axis => {
                    const slider = document.getElementById(`scene-trans-${axis}`);
                    if (slider) slider.value = 0;
                    const display = slider?.nextElementSibling;
                    if (display) display.textContent = '0.0';
                });
                ['yaw', 'pitch', 'roll'].forEach(id => {
                    const slider = document.getElementById(`scene-rot-${id}`);
                    if (slider) slider.value = 0;
                    const display = slider?.nextElementSibling;
                    if (display) display.textContent = '0°';
                });
                videoPlayer.resetSceneTransform();
            });
            panel.appendChild(resetBtn);

            const note = document.createElement('div');
            note.style.cssText = 'margin-top: 10px; font-size: 10px; opacity: 0.6; line-height: 1.3;';
            note.textContent = 'Transforms entire scene (path + clouds) as rigid body';
            panel.appendChild(note);

            document.body.appendChild(panel);
        }

        // ============================================================================

        // Initialize on load
        window.addEventListener('DOMContentLoaded', async () => {
            console.log('Initializing Depth Anything 3 UI...');

            updateApiDisplay();
            const apiPill = document.getElementById('api-base-display');
            if (apiPill) {
                apiPill.addEventListener('click', () => {
                    const next = prompt('Enter API base (e.g., http://127.0.0.1:5000)', API_BASE);
                    if (next) setApiBase(next);
                });
            }

            const apiReady = await verifyApiBase();
            if (!apiReady) {
                console.error('API base not reachable; UI init halted.');
                return;
            }

            // Initialize Three.js scene
            initThreeJS();
            console.log('Three.js scene initialized');

            // Build alignment helper UIs
            createSignFlipPanel();
            createSceneAlignmentPanel();

            // Setup event handlers
            setupDragAndDrop();
            setupModalCloseHandler();
            setupKeyboardControls();
            setupPointerLockControls();
            setupManualFloorSelection();
            syncConfigModalFromState();
            console.log('Event handlers setup complete');

            // Update model status
            updateModelStatus();
            hydrateModelStatus();
            console.log('UI initialization complete');
        });
    </script>
</body>
</html>
